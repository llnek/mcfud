!function(t,e,r){var s,i=256,o="random",n=r.pow(i,6),h=r.pow(2,52),l=2*h,a=255;function u(a,u,p){function m(){for(var t=x.g(6),e=n,r=0;t<h;)t=(t+r)*i,e*=i,r=x.g(1);for(;l<=t;)t/=2,e/=2,r>>>=1;return(t+r)/e}var y=[],w=f(function t(e,r){var s,i=[],o=typeof e;if(r&&"object"==o)for(s in e)try{i.push(t(e[s],r-1))}catch(t){}return i.length?i:"string"==o?e:e+"\0"}((u=1==u?{entropy:!0}:u||{}).entropy?[a,g(e)]:null==a?function(){try{var r;return s&&(r=s.randomBytes)?r=r(i):(r=new Uint8Array(i),(t.crypto||t.msCrypto).getRandomValues(r)),g(r)}catch(r){var o=t.navigator,n=o&&o.plugins;return[+new Date,t,n,t.screen,g(e)]}}():a,3),y),x=new c(y);return m.int32=function(){return 0|x.g(4)},m.quick=function(){return x.g(4)/4294967296},m.double=m,f(g(x.S),e),(u.pass||p||function(t,e,s,i){return i&&(i.S&&d(i,x),t.state=function(){return d(x,{})}),s?(r[o]=t,e):t})(m,w,"global"in u?u.global:this==r,u.state)}function c(t){var e,r=t.length,s=this,o=0,n=s.i=s.j=0,h=s.S=[];for(r||(t=[r++]);o<i;)h[o]=o++;for(o=0;o<i;o++)h[o]=h[n=a&n+t[o%r]+(e=h[o])],h[n]=e;(s.g=function(t){for(var e,r=0,o=s.i,n=s.j,h=s.S;t--;)e=h[o=a&o+1],r=r*i+h[a&(h[o]=h[n=a&n+e])+(h[n]=e)];return s.i=o,s.j=n,r})(i)}function d(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function f(t,e){for(var r,s=t+"",i=0;i<s.length;)e[a&i]=a&(r^=19*e[a&i])+s.charCodeAt(i++);return g(e)}function g(t){return String.fromCharCode.apply(0,t)}if(f(r.random(),e),"object"==typeof module&&module.exports){module.exports=u;try{s=require("crypto")}catch(u){}}else"function"==typeof define&&define.amd?define((function(){return u})):r["seed"+o]=u}("undefined"!=typeof self?self:this,[],Math),function(t,e,r){"use strict";function s(){const s=t,i=Math.floor,o=Array.prototype.slice,n=Object.prototype.toString;function h(t){return"[object Object]"==n.call(t)}function l(t){return"[object Function]"==n.call(t)}function a(t){return"[object Array]"==n.call(t)}function u(t){return"[object Map]"==n.call(t)}function c(t){return"[object Set]"==n.call(t)}function d(t){return"[object String]"==n.call(t)}function f(t){return"[object Number]"==n.call(t)}function g(t){return"[object Boolean]"==n.call(t)}function p(t){return t>0?t%2==0:-t%2==0}function m(t){return void 0===t}function y(t){return a(t)||u(t)||h(t)}let w=r?r():new Math.seedrandom;function x(t,e){for(let r,s=0;s<t.length;++s)if(r=t[s],!r[0](r[1]))throw new TypeError("wanted "+e);return!0}function k(t,e){for(let e,r=0;r<t.length;++r)if(e=t[r],e[0](e[1]))return!0;throw new TypeError("wanted "+e)}function _(t,e,r){if(t(e))return!0;throw new TypeError("wanted "+r)}const E=/(\/|\\\\)([^(\/|\\\\)]+)$/g,b=/(\.[^\.\/\?\\]*)(\?.*)?$/;function v(t,e){let r=b.exec(t);return r&&r[1]?(r=r[1].toLowerCase(),e||(r=r.substring(1))):r="",r}let N=0;function M(t,e,r){let s=t(e);switch(r.length){case 0:return s;case 1:return s&&t(r[0]);case 2:return s&&t(r[0])&&t(r[1]);case 3:return s&&t(r[0])&&t(r[1])&&t(r[2]);default:return s&&r.every(e=>t(e))}}const q={},z={fun:(t,...e)=>M(l,t,e),str:(t,...e)=>M(d,t,e),undef:(t,...e)=>M(m,t,e),map:(t,...e)=>M(u,t,e),set:(t,...e)=>M(c,t,e),num:(t,...e)=>M(f,t,e),bool:(t,...e)=>M(g,t,e),pos:t=>f(t)&&t>0,neg:t=>f(t)&&t<0,vec:(t,...e)=>M(a,t,e),obj:(t,...e)=>M(h,t,e),some:t=>A.size(t)>0,none:t=>0===A.size(t),own:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},A={error(...t){console.error(...t)},log(...t){console.log(...t)},srand(){w=r?r():new Math.seedrandom},feq0:t=>Math.abs(t)<1e-10,feq:(t,e)=>Math.abs(t-e)<1e-10,pack:t=>JSON.stringify(t),unpack:t=>JSON.parse(t),v2:(t=0,e=0)=>[t,e],p2:(t=0,e=0)=>({x:t,y:e}),numOrZero:t=>isNaN(t)?0:t,setVec(t,...e){e.forEach((e,r)=>t[r]=e)},evenN:(t,e)=>p(t=Math.floor(t))?t:e?t+1:t-1,nichts:t=>null==t,nor:(t,e)=>null==t?e:t,or:(t,e)=>void 0===t?e:t,toNum(t,e){const r=parseFloat(t);return isNaN(r)&&f(e)?e:r},percentRemain:(t,e,r)=>(t>e&&(t=r?t%e:e),Math.max(0,e-t)/e),splitVerStr(t){const e=(""+(t||"")).split(".").filter(t=>t.length>0);return[this.toNum(e[0],0),this.toNum(e[1],0),this.toNum(e[2],0)]},cmpVerStrs(t,e){let r=this.splitVerStr(""+t),s=this.splitVerStr(""+e);return r[0]>s[0]?1:r[0]<s[0]?-1:r[1]>s[1]?1:r[1]<s[1]?-1:r[2]>s[2]?1:r[2]<s[2]?-1:0},pdef:t=>(t.configurable=!0)&&(t.enumerable=!0)&&t,findFiles:(t,e)=>t.filter(t=>e.indexOf(v(t,1))>-1),partition(t,e){const r=[];for(let s,i,o=0;;){for(s=[],i=0;i<t;++i){if(!(o<e.length)){i=-1;break}s.push(e[o++])}if(s.length>0&&r.push(s),i<0)break}return r},keys:t=>u(t)?Array.from(t.keys()):h(t)?Object.keys(t):[],selectNotKeys(t,e){k([[u,t],[h,t]],"map/object");const r=u(t)?new Map:{};return e=this.seq(e),this.doseq(t,(t,s)=>!e.includes(s)&&this.assoc(r,s,t)),r},selectKeys(t,e){k([[u,t],[h,t]],"map/object");const r=u(t)?new Map:{};return this.seq(e).forEach(e=>{u(t)?t.has(e)&&r.set(e,t.get(e)):z.own(t,e)&&(r[e]=t[e])}),r},assertNot(t,...e){return this.assert(!t,...e)},assert(t,...e){if(!t)throw 0===e.length?"Assertion!":e.join("");return!0},noSuchKeys(t,e){return!this.some(this.seq(t),t=>this.has(e,t)?t:null)},randInt2:(t,e)=>function(t,e){return i(w()*(e-t+1)+t)}(t,e),randFloat:(t,e)=>t+w()*(e-t),randMinus1To1:()=>2*(w()-.5),randInt:t=>i(w()*t),rand:(t=!1)=>t?Math.random():w(),randSign:()=>w()>.5?-1:1,inst:(t,e)=>e instanceof t,hashCode(t){let e=0;for(let r=0;r<t.length;++r)e=Math.imul(31,e)+t.charCodeAt(r);return e},randItem(t,e){let r,s=-1;if(t)switch(t.length){case 0:case 1:r=t[s=0];break;case 2:r=t[s=this.randSign()>0?1:0];break;default:r=t[s=i(w()*t.length)]}return e?[r,s]:r},isPerc:t=>d(t)&&t.match(/^([0-9])(\.?[0-9]+|[0-9]*)%$/),isEven:t=>p(t),jsMap(...t){_(p,t.length,"even n# of args");let e=new Map;for(let r=0;r<t.length;)e.set(t[r],t[r+1]),r+=2;return e},jsObj(...t){_(p,t.length,"even n# of args");let e={};for(let r=0;r<t.length;)e[t[r]]=t[r+1],r+=2;return e},jsVec:(...t)=>0===t.length?[]:t.slice(),lastIndex:t=>a(t)&&t.length>0?t.length-1:-1,first(t){if(a(t)&&t.length>0)return t[0]},last(t){if(a(t)&&t.length>0)return t[t.length-1]},head(t){return this.first(t)},tail(t){return this.last(t)},floor:t=>Math.floor(t),ceil:t=>Math.ceil(t),abs:t=>Math.abs(t),sqrt:t=>Math.sqrt(t),min:(...t)=>Math.min(...t),max:(...t)=>Math.max(...t),slice:(t,e)=>o.call(t,e),every(t,e){_(a,t,"array");for(let r=0;r<t.length;++r)if(l(e)){if(!e(t[r]))return!1}else if(t[r]!=e)return!1;return t.length>0},notAny(t,e){_(a,t,"array");for(let r=0;r<t.length;++r)if(l(e)){if(e(t[r]))return!1}else if(t[r]===e)return!1;return t.length>0},copy(t,e=[]){x([[a,t],[a,e]],"arrays");const r=Math.min(t.length,e.length);for(let s=0;s<r;++s)t[s]=e[s];return t},append(t,e=[]){x([[a,t],[a,e]],"arrays");for(let r=0;r<e.length;++r)t.push(e[r]);return t},fill(t,e,...r){if(f(t)&&(t=new Array(t)),a(t))for(let s=0;s<t.length;++s)t[s]=l(e)?e(s,...r):e;return t},size(t){return a(t)||d(t)?t.length:c(t)||u(t)?t.size:t?this.keys(t).length:0},nextId:()=>++N,now:()=>Date.now(),fileExt:t=>v(t),fileBase(t){let e,r,s=t.indexOf("?");return s>0&&(t=t.substring(0,s)),t=t.replace(/(\/|\\\\)$/,""),r=E.exec(t),e="",r&&(e=r[2],s=e.lastIndexOf("."),s>0&&(e=e.substring(0,s))),e},range(t,e,r=1){1===arguments.length&&(e=t,t=0,r=1);let s=(e-t)/r;const i=[];s=Math.ceil(s),s=Math.max(0,s),i.length=s;for(let e=0;e<s;++e)i[e]=t,t+=r;return i},shuffle(t,e=!0){_(a,t,"array");const r=o.call(t,0);switch(r.length){case 0:case 1:break;case 2:if(this.randSign()>0){let t=r[0];r[0]=r[1],r[1]=t}break;default:for(let t,e,s=r.length-1;s>0;--s)e=i(w()*(s+1)),t=r[s],r[s]=r[e],r[e]=t}return e?this.copy(t,r):r},shuffle2(t,e=!0){if(_(a,t,"array"),t.length<3)t=this.shuffle(t,e);else{const e=t.length;o.call(t,0);for(let r,s,o=0;o<e;++o)s=o+i(w()*(e-o)),r=t[s],t[s]=t[o],t[o]=r}return t},uniq:t=>(_(a,t,"array"),Array.from(new Set(t))),map(t,e,r){if(_(y,t,"array/map/object"),a(t))return t.map(e,r);{const s=u(t)?new Map:{};return this.doseq(t,(i,o)=>{this.assoc(s,o,e.call(r,i,o,t))}),s}},find(t,e,r){let s,i=!0,n=o.call(arguments,3);return this.doseq(t,(t,o)=>{i&&e.apply(r,[t,o].concat(n))&&(s=[o,t],i=!1)}),s},some(t,e,r){let s,i=!0,n=o.call(arguments,3);return this.doseq(t,(t,o)=>{i&&(s=e.apply(r,[t,o].concat(n)),s?i=!1:s=void 0)}),s},invoke(t,e){let r=o.call(arguments,2);a(t)&&t.forEach(t=>t[e].apply(t,r))},delay:(t,e)=>setTimeout(e,t),timer:(t,e=0,r=!1)=>({repeat:!!r,id:r?setInterval(t,e):setTimeout(t,e)}),clear(t){t&&t.id?(t.repeat?clearInterval(t.id):clearTimeout(t.id),t.id=0):z.pos(t)&&clearTimeout(t)},dotimes(t,e,r,...s){for(let i=0;i<t;++i)e.call(r,i,...s)},rseq(t,e,r){if(_(a,t,"array"),t.length>0)for(let s=t.length-1;s>=0;--s)e.call(r,t[s],s,t)},doseq(t,e,r){a(t)?t.forEach(e,r):u(t)?t.forEach((s,i)=>e.call(r,s,i,t)):h(t)&&Object.keys(t).forEach(s=>e.call(r,t[s],s,t))},doseqEx(t,e,r){this.doseq(t,(s,i)=>null!=s&&e.call(r,s,i,t))},dissoc(t,e){if(arguments.length>2){let e,r=1;for(;r<arguments.length;++r)e=this.dissoc(t,arguments[r]);return e}{let r;return u(t)?(r=t.get(e),t.delete(e)):h(t)&&(r=t[e],delete t[e]),r}},get(t,e){if(void 0!==e){if(u(t))return t.get(e);if(t)return t[e]}},assoc(t,e,r){if(arguments.length>3){if((arguments.length-1)%2!=0)throw"wanted even count of args";let e,r=1;for(;r<arguments.length;)e=this.assoc(t,arguments[r],arguments[r+1]),r+=2;return e}{let s;return u(t)?(s=t.get(e),t.set(e,r)):t&&(s=t[e],t[e]=r),s}},disj(t,e){const r=t?t.indexOf(e):-1;return r>-1&&t.splice(r,1),r>-1},conj:(t,...e)=>(t&&e.forEach(e=>t.push(e)),t),seq:(t,e=/[,; \t\n]+/)=>("string"==typeof t&&(t=t.split(e).map(t=>t.trim()).filter(t=>t.length>0)),a(t)||(t=[t]),t),has(t,e){return 1!==arguments.length&&(u(t)?t.has(e):a(t)?-1!==t.indexOf(e):!!h(t)&&z.own(t,e))},patch(t,e){return _(h,t=t||{},"object"),e&&Object.keys(e).forEach(r=>{this.has(t,r)||(t[r]=e[r])}),t},clone(t){return t?this.unpack(this.pack(t)):t},inject:(t,...e)=>(t=t||{},e.forEach(e=>e&&function(t,e){let r=Object.keys(e).reduce((t,r)=>(t[r]=Object.getOwnPropertyDescriptor(e,r),t),{});return Object.getOwnPropertySymbols(e).forEach(t=>{let s=Object.getOwnPropertyDescriptor(e,t);s.enumerable&&(r[t]=s)}),Object.defineProperties(t,r),t}(t,e)),t),deepCopyArray(t){_(a,t,"array");const e=[];for(let r=0,s=t.length;r<s;++r)e[r]=a(t[r])?this.deepCopyArray(t[r]):t[r];return e},mergeEx(t,e){return this.merge(this.merge({},t),e)},merge(t,e){let r;return Object.keys(e).forEach(s=>{r=e[s],"object"==typeof r&&null!==r&&t[s]?("object"!=typeof t[s]&&(t[s]=r instanceof Array?[]:{}),this.merge(t[s],r)):t[s]=r}),t},throttle(t,e,r){let s=!0,i=!0;if("function"!=typeof t)throw new TypeError("Expected a function");return h(r)&&(s="leading"in r?!!r.leading:s,i="trailing"in r?!!r.trailing:i),this.debounce(t,e,{leading:s,trailing:i,maxWait:e})},debounce(t,e,r){let i,o,n,l,a,u,c=0,d=!1,f=!1,g=!0;const p=!e&&0!==e&&"function"==typeof s.requestAnimationFrame;if("function"!=typeof t)throw new TypeError("Expected a function");function m(e){const r=i,s=o;return i=o=void 0,c=e,l=t.apply(s,r),l}function y(t,e){return p?(s.cancelAnimationFrame(a),s.requestAnimationFrame(t)):setTimeout(t,e)}function w(t){const r=t-u;return void 0===u||r>=e||r<0||f&&t-c>=n}function x(){const t=Date.now();if(w(t))return k(t);a=y(x,function(t){const r=t-c,s=e-(t-u);return f?Math.min(s,n-r):s}(t))}function k(t){return a=void 0,g&&i?m(t):(i=o=void 0,l)}function _(...t){const r=Date.now(),s=w(r);if(i=t,o=this,u=r,s){if(void 0===a)return function(t){return c=t,a=y(x,e),d?m(t):l}(u);if(f)return a=y(x,e),m(u)}return void 0===a&&(a=y(x,e)),l}return e=+e||0,h(r)&&(d=!!r.leading,f="maxWait"in r,n=f?Math.max(+r.maxWait||0,e):n,g="trailing"in r?!!r.trailing:g),_.cancel=function(){void 0!==a&&function(t){if(p)return s.cancelAnimationFrame(t);clearTimeout(t)}(a),c=0,i=u=o=a=void 0},_.flush=function(){return void 0===a?l:k(Date.now())},_.pending=function(){return void 0!==a},_},negate:t=>(_(l,t,"function"),function(...e){return!t.apply(this,e)}),strPadRight:(t,e,r)=>(e-=t.length)>0?t+new Array(Math.ceil(e/r.length)+1).join(r).substr(0,e):t,strPadLeft:(t,e,r)=>(e-=t.length)>0?new Array(Math.ceil(e/r.length)+1).join(r).substr(0,e)+t:t,safeSplit:(t,e)=>(t||"").trim().split(e).filter(t=>t.length>0),capitalize:t=>t.charAt(0).toUpperCase()+t.slice(1),prettyNumber(t,e=2){return this.strPadLeft(Number(t).toString(),e,"0")},prettyMillis(t){let e,r,s=i(t/1e3);r=i(s/60),t-=1e3*s,s-=60*r,e=i(r/60),r-=60*e;let o=[];return o.push(`${s}.${t} secs`),(r>0||e>0)&&o.push(r+" mins, "),e>0&&o.push(e+" hrs, "),o.reverse().join("")},dropArgs:(t,e)=>t.length>e?o.call(t,e):[],isSSL:()=>t&&t.location&&t.location.protocol.indexOf("https")>=0,isMobile:t=>t&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(t.userAgent),isSafari:t=>t&&/Safari/.test(t.userAgent)&&/Apple Computer/.test(t.vendor),isCrossOrigin(e){let r=t;if(2===arguments.length&&911===arguments[1].hack&&(r=arguments[1]),r&&r.location&&e){const t=e.indexOf("://");if(t>0){let s=e.indexOf("/",t+3);return(s<0?e:e.substring(0,s))!=r.location.origin}}},addEvent(t,e,r,s){a(t)&&1===arguments.length?t.forEach(t=>this.addEvent.apply(this,t)):e.addEventListener(t,r,s)},delEvent(t,e,r,s){a(t)&&1===arguments.length?t.forEach(t=>this.delEvent.apply(this,t)):e.removeEventListener(t,r,s)}},T={qSelector:t=>e.querySelectorAll(t),qId:t=>e.getElementById(t),parent(t){if(t)return t.parentNode},conj:(t,e)=>t.appendChild(e),byTag:(t,r)=>d(r)?e.getElementsByTagNameNS(r,t):e.getElementsByTagName(id),attrs(t,e){return!h(e)&&e?(arguments.length>2&&t.setAttribute(e,arguments[2]),t.getAttribute(e)):(e&&A.doseq(e,(e,r)=>t.setAttribute(r,e)),t)},css(t,e){return!h(e)&&e?(arguments.length>2&&(t.style[e]=arguments[2]),t.style[e]):(e&&A.doseq(e,(e,r)=>t.style[r]=e),t)},wrap(t,e){const r=t.parentNode;return e.appendChild(t),r.appendChild(e),e},newElm(t,r,s){const i=e.createElement(t);return this.attrs(i,r),this.css(i,s),i},newTxt(t,r,s){const i=e.createTextNode(t);return this.attrs(i,r),this.css(i,s),i}},S={},P=[];class j{constructor(){this._tree=new Map,this._targets=new Map}sub(t,e,r,s){let i=t[0],o=t[1];return o&&!this._targets.has(o)&&this._targets.set(o,1),A.seq(i).forEach(t=>{if(e||(e=t),d(e)&&(e=(r=r||o)[e]),!e)throw"Error: no callback for sub()";this._tree.has(t)||this._tree.set(t,A.jsMap());let i=this._tree.get(t);o=o||S,!i.has(o)&&i.set(o,[]),i.get(o).push([e,r,s])}),this}pub(t,...e){let r,s,i=t[0],o=t[1]||S;return(o===S||this._targets.has(o))&&A.seq(i).forEach(t=>{s=this._tree.get(t),r=s&&s.get(o),r&&r.forEach(t=>{t[0].apply(t[1],e.concat(t[2]||P))})}),this}reset(){return this._targets.clear(),this._tree.clear(),this}drop(t){if(this._targets.has(t)){this._targets.delete(t);let e=this._tree.values();for(let r=e.next();!r.done;)r.value.delete(t),r=e.next()}return this}unsub(t,e,r){if(1!==arguments.length||z.vec(t)){let s=t[0],i=t[1]||S;if(i===S||this._targets.has(i)){let t,o;A.seq(s).forEach(s=>{if(t=this._tree.get(s),o=t&&t.get(i),o&&(d(e)&&(e=(r=r||i)[e]),e))for(let t=o.length-1;t>=0;--t)o[t][0]===e&&o[t][1]===r&&o.splice(t,1)})}}else this.drop(t);return this}}return e?q.dom=T:(delete A.addEvent,delete A.delEvent),q.EventBus=function(){return new j},q.is=z,q.u=A,q}"object"==typeof module&&module.exports?r=require("../tpcl/seedrandom.min"):e=t.document,"object"==typeof module&&module.exports?module.exports=s():t["io/czlab/mcfud/core"]=s}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const r=360,s=2*Math.PI,{is:i,u:o}=(Math.PI,e);function n(t){return t<0?- -t%r:t%r}return{lerp:(t,e,r)=>(1-r)*t+r*e,xmod:(t,e)=>t<0?t- -(e+e*Math.floor(-t/e)):t%e,clamp:(t,e,r)=>r<t?t:r>e?e:r,sqr:t=>t*t,fuzzyEq:(t,e)=>o.feq(t,e),fuzzyZero:t=>o.feq0(t),radToDeg:t=>n(r*t/s),degToRad:t=>s*n(t)/r,pythag2:(t,e)=>t*t+e*e,pythag:(t,e)=>Math.sqrt(t*t+e*e),wrap:(t,e)=>(t+1)%e,biasGreater:(t,e)=>t>=.95*e+.01*t}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/math"]=e}(this),function(t){"use strict";function e(e=null){e||(e=t["io/czlab/mcfud/core"]());const{u:r,is:s}=e;function i(t,e){r.assert(!s.num(t)&&!s.num(e)&&t&&e,"wanted 2 vecs")}function o(t,e=0,r=0){return t?[e,r]:{x:e,y:r}}const n={};class h{constructor(){this.x=0,this.y=0}unit(t){return s.bool(t)&&(t=o(t)),s.vec(t)?(t[0]=this.x,t[1]=this.y):(t.x=this.x,t.y=this.y),t}bind(t){return s.vec(t)?(this.x=t[0],this.y=t[1]):(this.x=t.x,this.y=t.y),this}op(t,e,r){let i=n.take();switch(i.x=this.x,i.y=this.y,t){case"+":s.num(e)&&(i.x+=e),s.num(r)&&(i.y+=r);break;case"-":s.num(e)&&(i.x-=e),s.num(r)&&(i.y-=r);break;case"*":s.num(e)&&(i.x*=e),s.num(r)&&(i.y*=r);break;case"/":s.num(e)&&(i.x/=e),s.num(r)&&(i.y/=r)}return i}"+"(t){return this.op("+",t.x,t.y)}"-"(t){return this.op("-",t.x,t.y)}"*"(t){return this.op("*",t.x,t.y)}"/"(t){return this.op("/",t.x,t.y)}}function l(t,e,r,i,o,n,h){const l=t-o,a=e-n,u=o+(l*r-a*i),c=n+(l*i+a*r);return s.vec(h)?(h[0]=u,h[1]=c):(h.x=u,h.y=c),h}function a(t,e,r,i){let o,h,l=n.take().bind(t);if(s.num(e))h=l.op(r,e,e);else{let t=n.take().bind(e);h=l[r](t),n.drop(t)}return o=h.unit(i?t:s.vec(t)),n.drop(l,h),o}r.inject(n,{take(){return this._pool.pop()},drop(...t){t.forEach(t=>{t.x=0,t.y=0,this._pool.push(t)})},_pool:r.fill(16,()=>new h)});return{vec:(t=0,e=0)=>o(!0,t,e),vecXY:(t=0,e=0)=>o(!1,t,e),add(t,e){return r.assert(2===arguments.length)&&a(t,e,"+")},add$(t,e){return r.assert(2===arguments.length)&&a(t,e,"+",!0)},sub(t,e){return r.assert(2===arguments.length)&&a(t,e,"-")},sub$(t,e){return r.assert(2===arguments.length)&&a(t,e,"-",!0)},mul(t,e){return r.assert(2===arguments.length)&&a(t,e,"*")},mul$(t,e){return r.assert(2===arguments.length)&&a(t,e,"*",!0)},div(t,e){return r.assert(2===arguments.length)&&a(t,e,"/")},div$(t,e){return r.assert(2===arguments.length)&&a(t,e,"/",!0)},dot(t,e){i(t,e);let r=n.take().bind(t),s=n.take().bind(e),o=r.x*s.x+r.y*s.y;return n.drop(r,s),o},equals(t,e){let r=n.take().bind(t),s=n.take().bind(e);return ok=r.x==s.x&&r.y==s.y,n.drop(r,s),ok},vecAB(t,e){i(t,e);let r=n.take().bind(t),o=n.take().bind(e),h=n.take();h.x=o.x-r.x,h.y=o.y-r.y;let l=h.unit(s.vec(t));return n.drop(r,o,h),l},len2(t){return this.dot(t,t)},len(t){return Math.sqrt(this.len2(t))},dist2(t,e){return this.len2(this.sub(e,t))},dist(t,e){return Math.sqrt(this.dist2(t,e))},unit(t){let e=n.take().bind(t),i=this.len(t);r.feq0(i)?(e.x=0,e.y=0):(e.x/=i,e.y/=i);let o=e.unit(s.vec(t));return n.drop(e),o},unit$(t){let e=n.take().bind(t),s=this.len(t);r.feq0(s)?(e.x=0,e.y=0):(e.x/=s,e.y/=s);let i=e.unit(t);return n.drop(e),i},copy(t,e){i(t,e);let r=n.take().bind(t),s=n.take().bind(e);r.x=s.x,r.y=s.y;let o=r.unit(t);return n.drop(r,s),o},clone(t){let e=n.take().bind(t),r=e.unit(s.vec(t));return n.drop(e),r},set(t,e,r){let i=n.take().bind(t);s.num(e)&&(i.x=e),s.num(r)&&(i.y=r);let o=i.unit(t);return n.drop(i),o},setX(t,e){return this.set(t,e)},setY(t,e){return this.set(t,null,e)},rot(t,e,r=null){let i=n.take().bind(t),h=0,a=0;if(r){let t=n.take().bind(r);h=t.x,a=t.y,n.drop(t)}let u=l(i.x,i.y,Math.cos(e),Math.sin(e),h,a,o(s.vec(t)));return n.drop(i),u},rot$(t,e,r){let s=n.take().bind(t),i=0,o=0;if(r){let t=n.take().bind(r);i=t.x,o=t.y,n.drop(t)}let h=l(s.x,s.y,Math.cos(e),Math.sin(e),i,o,t);return n.drop(s),h},cross(t,e){let r;if(s.num(t)){let i=n.take().bind(e),o=n.take();o.x=-t*i.y,o.y=t*i.x,r=o.unit(s.vec(e)),n.drop(i,o)}else if(s.num(e)){let i=n.take().bind(t),o=n.take();o.x=e*i.y,o.y=-e*i.x,r=o.unit(s.vec(t)),n.drop(i,o)}else{i(t,e);let s=n.take().bind(t),o=n.take().bind(e);r=s.x*o.y-s.y*o.x,n.drop(s,o)}return r},angle(t,e){return Math.acos(this.dot(t,e)/(this.len(t)*this.len(e)))},normal(t,e=!1){let r=n.take().bind(t),i=n.take();e?(i.x=-r.y,i.y=r.x):(i.x=r.y,i.y=-r.x);let o=i.unit(s.vec(t));return n.drop(r,i),o},normal$(t,e=!1){let r=n.take().bind(t),s=n.take();e?(s.x=-r.y,s.y=r.x):(s.x=r.y,s.y=-r.x);let i=s.unit(t);return n.drop(r,s),i},proj_scalar(t,e){return this.dot(t,e)/this.len(e)},proj(t,e){const r=this.unit(e);this.mul$(r,this.dot(t,r));let i=n.take().bind(r),o=i.unit(s.vec(t));return n.drop(i),o},perp(t,e){return this.sub(t,this.proj(t,e))},reflect(t,e){let r=2*this.dot(t,e);return this.sub(t,this.mul(e,r))},flip(t){return this.mul(t,-1)},flip$(t){return this.mul$(t,-1)},translate(t,...e){let r,i,o,h,l=n.take().bind(t);return 1===e.length&&s.vec(e[0])&&!s.num(e[0][0])&&(e=e[0]),o=e.map(t=>(i=n.take().bind(t),r=i["+"](l),h=r.unit(s.vec(t)),n.drop(i,r),h)),n.drop(l),o}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/vec2"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());Math.atan2;const r=Math.cos,s=Math.sin,i=(Math.tan,Math.floor),{u:o,is:n}=e;function h(t){return t%2!=0}function l(t,e,r,s){return s-1+(r-1)*e}function a(t,e,r){return{dim:[t,e],cells:r}}function u(t,e){return a(t,e,o.fill(t*e,0))}return{v4:(t=0,e=0,r=0,s=0)=>[t,e,r,s],v3:(t=0,e=0,r=0)=>[t,e,r],dot:(t,e)=>t[0]*e[0]+t[1]*e[1]+t[2]*e[2],cross(t,e){return this.v3(t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0])},len2(t){return this.dot(t,t)},len(t){return Math.sqrt(this.len2(t))},unit(t){let e=this.len(t);if(!o.feq0(e))return[t[0]/e,t[1]/e,t[2]/e]},sub(t,e){return n.num(e)?this.v3(t[0]-e,t[1]-e,t[2]-e):this.v3(t[0]-e[0],t[1]-e[1],t[2]-e[2])},add(t,e){return n.num(e)?this.v3(t[0]+e,t[1]+e,t[2]+e):this.v3(t[0]+e[0],t[1]+e[1],t[2]+e[2])},mul(t,e){return n.num(e)?this.v3(t[0]*e,t[1]*e,t[2]*e):this.v3(t[0]*e[0],t[1]*e[1],t[2]*e[2])},div(t,e){return n.num(e)?this.v3(t[0]/e,t[1]/e,t[2]/e):this.v3(t[0]/e[0],t[1]/e[1],t[2]/e[2])},matrix([t,e],...r){const s=t*e;return 0===r.length?u(t,e):o.assert(s===r.length)&&a(t,e,r)},matCell(t,e,r,s){const i=l(t.dim[0],t.dim[1],e,r);if(i>=0&&i<t.cells.length)return n.num(s)?(t.cells[i]=s,t):t.cells[i]},matIdentity(t){const e=o.assert(t>0)&&o.fill(t*t,0);for(let r=0;r<t;++r)e[l(0,t,r+1,r+1)]=1;return a(t,t,e)},matZero:t=>o.assert(t>0)&&a(t,t,o.fill(t*t,0)),matRowMajors(t){const[e,r]=t.dim;return o.partition(r,t.cells)},matColMajors(t){const[e,r]=t.dim,s=[];for(let i,o=0;o<r;++o){i=[];for(let s=0;s<e;++s)i.push(t.cells[s*r+o]);s.push(i)}return s},mat2(t,e,r,s){return this.matrix([2,2],t,e,r,s)},mat3(t,e,r,s,i,o,n,h,l){return this.matrix([3,3],t,e,r,s,i,o,n,h,l)},mat4(t,e,r,s,i,o,n,h,l,a,u,c,d,f,g,p){return this.matrix([4,4],t,e,r,s,i,o,n,h,l,a,u,c,d,f,g,p)},matEq:(t,e)=>t.dim[0]===e.dim[0]&&t.dim[1]===e.dim[1]&&function(t,e){for(let r=0;r<t.length;++r)if(!o.feq(t[r],e[r]))return!1;return!0}(t.cells,e.cells),matXpose(t){const[e,r]=t.dim,s=e*r,o=[];for(let n=0;n<s;++n)o.push(t.cells[i(n/e)+r*(n%e)]);return a(r,e,o)},matScale:(t,e)=>a(t.dim[0],t.dim[1],t.cells.map(t=>t*e)),matMult(t,e){let[r,s]=t.dim,[i,n]=e.dim,h=t.cells,l=e.cells;o.assert(s===i,"mismatch matrices");let u=new Array(r*n);for(let t=0;t<r;++t)for(let e=0;e<n;++e)u[e+t*n]=o.range(i).reduce((r,i)=>r+h[i+t*s]*l[e+i*n],0);return a(r,n,u)},matDet(t){let[e,r]=t.dim,s=[];if(2===r)return this._matDet2x2(t);for(let e=0;e<r;++e)o.conj(s,this.matDet(this.matCut(t,1,e+1)));return o.range(r).reduce((e,r)=>{let i=s[r];return e+t.cells[r]*(h(r)?-i:i)},0)},_matDet2x2:t=>(o.assert(4===t.cells.length),t.cells[0]*t.cells[3]-t.cells[1]*t.cells[2]),matCut(t,e,r){const[s,i]=t.dim;let n=e-1,h=r-1,l=[];for(let e=0;e<s;++e)for(let r=0;r<i;++r)e!==n&&r!==h&&o.conj(l,t.cells[r+e*i]);return a(s-1,i-1,l)},matMinor(t){const[e,r]=t.dim;let s=[];if(o.assert(e===r),2===r)return this._matMinor2x2(t);for(let i=0;i<e;++i)for(let e=0;e<r;++e)o.conj(s,this.matDet(this.matCut(t,i+1,e+1)));return a(e,r,s)},_matMinor2x2(t){return o.assert(4===t.cells.length)&&this.mat2(t.cells[3],t.cells[2],t.cells[1],t.cells[0])},matCofactor(t){const e=this.matMinor(t),[r,s]=e.dim;let i=e.cells.slice();for(let t=0;t<r;++t)for(let e,r=0;r<s;++r)e=t*s+r,h(t+r)&&(i[e]=-i[e]);return a(r,s,i)},matAdjugate(t){return this.matXpose(this.matCofactor(t))},_minv2x2(t){const[e,r]=t.dim;o.assert(4===t.cells.length&&2===e&&2===r);let s,i=t.cells,n=i[0]*i[3]-i[1]*i[2];if(o.feq0(n))s=this.matIdentity(e);else{let t=1/n;s=this.mat2(i[3]*t,-i[1]*t,-i[2]*t,i[0]*t)}return s},matInv(t){const[e,r]=t.dim;if(2===r)return this._minv2x2(t);let s=this.matDet(t);return o.feq0(s)?this.matIdentity(e):this.matScale(this.matAdjugate(t),1/s)},matFromColMajor(t){let e=t.length,r=u(t[0].length,e);for(let s,i=0;i<t.length;++i){s=t[i];for(let t=0;t<s.length;++t)r.cells[t*e+i]=s[t]}return r},matToColMajor(t){const[e,r]=t.dim,s=[];t.cells.slice();for(let i,o=0;o<r;++o){i=[];for(let s=0;s<e;++s)i.push(t.cells[s*r+o]);s.push(i)}return s},scale3D(t){const e=this.matIdentity(4);return e.cells[l(0,4,1,1)]=t[0],e.cells[l(0,4,2,2)]=t[1],e.cells[l(0,4,3,3)]=t[2],e},translate3D(t){const e=this.matIdentity(4);return e.cells[l(0,4,4,1)]=t[0],e.cells[l(0,4,4,2)]=t[1],e.cells[l(0,4,4,3)]=t[2],e},rot3D(t,e,r){return this.matMult(this.zRot3D(r),this.matMult(this.yRot3D(e),this.xRot3D(t)))},matVMult(t,e){let r=t.dim[1],s=e.length;o.assert(r===s);let i=this.matMult(t,a(s,1,e)),n=i.cells;return i.cells=null,n},rot2D(t){return this.mat2(r(t),-s(t),s(t),r(t))},xRot3D(t){return this.mat4(1,0,0,0,0,r(t),-s(t),0,0,s(t),r(t),0,0,0,0,1)},yRot3D(t){return this.mat4(r(t),0,s(t),0,0,1,0,0,-s(t),0,r(t),0,0,0,0,1)},zRot3D(t){return this.mat4(r(t),-s(t),0,0,s(t),r(t),0,0,0,0,1,0,0,0,0,1)},isIdentity(t){const[e,r]=t.dim;if(e===r){for(let s,i=0;i<e;++i)for(let e=0;e<r;++e)if(s=t.cells[i*r+e],i+1===e+1){if(1!==s)return!1}else if(0!==s)return!1;return!0}return!1},isOrthogonal(t){let e=this.matDet(t);return 1===Math.abs(e)&&this.isIdentity(this.matMult(this.matXpose(t),this.matInv(t)))}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/matrix"]=e}(this),function(t){"use strict";const e=" @N/\\Ri2}aP`(xeT4F3mt;8~%r0v:L5$+Z{'V)\"CKIc>z.*fJEwSU7juYg<klO&1?[h9=n,yoQGsW]BMHpXb6A|D#q^_d!-",r=e.length;function s(s){s||(s=t["io/czlab/mcfud/core"]());const{u:i}=s;function o(t){return Math.abs(t)%r}function n(t,r){return(r||e).charAt(t)}function h(t){for(let e=0;e<r;++e)if(n(e)===t)return e;return-1}function l(t,e){let s=e+t;return n(s>=r?s-r:s)}function a(t,e){let s=e-t;return n(s<0?r+s:s)}return{encrypt(t,e){if(0===e)return t;let r,s=[],i=o(e);return t.split("").forEach(t=>{r=h(t),s.push(r<0?t:function(t,e,r){return t<0?l(e,r):a(e,r)}(e,i,r))}),s.join("")},decrypt(t,e){if(0===e)return t;let r,s=[],i=o(e);return t.split("").forEach(t=>{r=h(t),s.push(r<0?t:function(t,e,r){return t<0?a(e,r):l(e,r)}(e,i,r))}),s.join("")}}}"object"==typeof module&&module.exports?module.exports=s(require("./core")):t["io/czlab/mcfud/crypt"]=s}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());return{fsm(t){let e=t.initState();return{state:()=>e,process(){const r=t[e];r&&r.run&&r.run()},trigger(r="change",s){const i=t[e],o=i&&i.transitions[r];if(o){const r=o.target,n=t[r];if(n)return i.exit&&i.exit(),n.enter&&n.enter(),s&&s.action?s.action():o.action&&(s?o.action(s):o.action()),e=r}}}}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/fsm"]=e}(this),function(t){"use strict";function e(e,r){e||(e=t["io/czlab/mcfud/core"]()),r||(r=t["io/czlab/mcfud/math"]());const s=2*Math.PI,{u:i}=e;return{TXMatrix2D:class{constructor(t){t?(this.m=[],this.clone(t)):this.m=[1,0,0,0,1,0]}identity(){const t=this.m;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,this}clone(t){let e=this.m,r=t.m;return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],this}multiply(t){let e=this.m,r=t.m,s=e[0]*r[0]+e[1]*r[3],i=e[0]*r[1]+e[1]*r[4],o=e[0]*r[2]+e[1]*r[5]+e[2],n=e[3]*r[0]+e[4]*r[3],h=e[3]*r[1]+e[4]*r[4],l=e[3]*r[2]+e[4]*r[5]+e[5];return e[0]=s,e[1]=i,e[2]=o,e[3]=n,e[4]=h,e[5]=l,this}rotate(t){if(!i.feq0(t)){let e=this.m,r=Math.cos(t),s=Math.sin(t),i=e[0]*r+e[1]*s,o=-e[0]*s+e[1]*r,n=e[3]*r+e[4]*s,h=-e[3]*s+e[4]*r;e[0]=i,e[1]=o,e[3]=n,e[4]=h}return this}rotateDeg(t){return i.feq0(t)?this:this.rotate(Math.PI*t/180)}scale(t,e){let r=this.m;return void 0===e&&(e=t),r[0]*=t,r[1]*=e,r[3]*=t,r[4]*=e,this}translate(t,e){let r=this.m;return r[2]+=r[0]*t+r[1]*e,r[5]+=r[3]*t+r[4]*e,this}transform(t,e){return[t*this.m[0]+e*this.m[1]+this.m[2],t*this.m[3]+e*this.m[4]+this.m[5]]}transformPoint(t){const[e,r]=this.transform(t.x,t.y);return t.x=e,t.y=r,t}transformArray(t){return this.transform(t[0],t[1])}setContextTransform(t){const e=this.m;t.transform(e[0],e[3],e[1],e[4],e[2],e[5])}},textStyle(t,e,r,s){const i={font:t,fill:e};return r&&(i.align=r),s&&(i.base=s),i},drawShape(t,e,...r){e&&e.draw&&e.draw(t,...r)},cfgStyle(t,e){const{line:r,stroke:s}=e;r&&(r.cap&&(t.lineCap=r.cap),r.width&&(t.lineWidth=r.width)),s&&s.style&&(t.strokeStyle=s.style)},drawPoints(t,e,r){void 0===r&&(r=e.length),i.assert(r<=e.length),t.beginPath();for(let s,i,o,n=0;n<r;++n)o=(n+1)%r,s=e[n],i=e[o],t.moveTo(s[0],s[1]),t.lineTo(i[0],i[1]);t.stroke()},drawShapePoly(t,e){return this.drawPoints(t,e.points)},drawCircle(t,e,r,i){t.beginPath(),t.arc(e,r,i,0,s,!0),t.closePath(),t.stroke()},drawShapeCircle(t,e){return this.drawCircle(t,e.pos[0],e.pos[1],e.radius)},drawRect(t,e,r,s,i,o){let n=e,h=r-i;t.save(),t.translate(n,h),t.rotate(o),t.strokeRect(0,0,s,i),t.restore()},drawShapeRect(t,e){return this.drawRect(t,e.pos[0],e.pos[1],e.width,e.height,e.rotation)},drawLine(t,e,r,s,i){t.beginPath(),t.moveTo(e,r),t.lineTo(s,i),t.stroke()},drawShapeLine(t,e){return this.drawLine(t,e.p[0],e.p[1],e.q[0],e.q[1])}}}"object"==typeof module&&module.exports?module.exports=e(require("./core"),require("./math")):t["io/czlab/mcfud/gfx"]=e}(this),function(t){"use strict";const[e,r,s]=[1,0,-1];function i(i,o,n){i||(i=t["io/czlab/mcfud/core"]()),o||(o=t["io/czlab/mcfud/math"]()),n||(n=t["io/czlab/mcfud/vec2"]());const h=Math.floor,l=Math.abs,{u:a}=i;function u(t){const e=t.length,r=a.assert(e<=36)&&a.fill(36);let s=0,i=t[0][0];for(let r,o=1;o<e;++o)r=t[o][0],r>i?(i=r,s=o):a.feq(r,i)&&t[o][1]<t[s][1]&&(s=o);let o=0,h=s;for(;;){r[o]=h;let i=0,l=r[o];for(let r,s,o,u=1;u<e;++u)i!==h?(r=n.sub(t[i],t[l]),s=n.sub(t[u],t[l]),o=n.cross(r,s),o<0&&(i=u),a.feq0(o)&&n.len2(s)>n.len2(r)&&(i=u)):i=u;if(h=i,++o,i===s)break}const l=[];for(let e=0;e<o;++e)l.push(n.clone(t[r[e]]));return l}class c{constructor(t,e,r,s){switch(arguments.length){case 2:this.pos=n.vec(),this.width=t,this.height=e;break;case 4:this.pos=n.vec(t,e),this.width=r,this.height=s;break;default:throw"Error: bad input to Rect()"}}}class d{constructor(t,e){this.width=t,this.height=e}half(){return new d(h(this.width/2),h(this.height/2))}}class f{constructor(t,e,r,s){this.p=n.vec(t,e),this.q=n.vec(r,s)}}class g{constructor(t,e){this.calcPoints=null,this.normals=null,this.edges=null,this.points=null,this.orient=0,this.pos=n.vec(),this.setPos(t,e)}setPos(t=0,e=0){return n.set(this.pos,t,e),this}set(t){return this.calcPoints=this.calcPoints||[],this.normals=this.normals||[],this.edges=this.edges||[],this.calcPoints.length=0,this.normals.length=0,this.edges.length=0,this.points=a.assert(t.length>2)&&u(t),a.doseq(this.points,t=>{this.calcPoints.push(n.vec()),this.edges.push(n.vec()),this.normals.push(n.vec())}),this._recalc()}setOrient(t){return this.orient=t,this._recalc()}translate(t,e){return a.doseq(this.points,r=>{r[0]+=t,r[1]+=e}),this._recalc()}_recalc(){if(this.points){let t,e,r;a.doseq(this.points,(t,e)=>{n.copy(this.calcPoints[e],t),a.feq0(this.orient)||n.rot$(this.calcPoints[e],this.orient)}),a.doseq(this.points,(s,i)=>{t=(i+1)%this.calcPoints.length,e=this.calcPoints[i],r=this.calcPoints[t],this.edges[i]=n.sub(r,e),this.normals[i]=n.unit(n.normal(this.edges[i]))})}return this}static translateCalcPoints(t){return n.translate(t.pos,t.calcPoints)}}class p{constructor(t,e){this.overlapN=n.vec(),this.overlapV=n.vec(),this.A=t,this.B=e,this.clear()}swap(){let t=new p,e=this.AInB,r=this.BInA,s=this.A;return t.overlap=this.overlap,t.A=this.B,t.B=s,t.AInB=r,t.BInA=e,t.overlapN=n.flip(this.overlapN),t.overlapV=n.flip(this.overlapV),t}clear(){return this.overlap=1/0,this.AInB=!0,this.BInA=!0,this}}function m(t,e){let r=1/0,s=-1/0;for(let i,o=0;o<t.length;++o)i=n.dot(t[o],e),i<r&&(r=i),i>s&&(s=i);return[r,s]}function y(t,i){let o=n.len2(t),h=n.dot(i,t);return h<0?e:h>o?s:r}function w(t,e,r,s,i,o){let[h,l]=m(e,i),[a,u]=m(s,i),c=n.vecAB(t,r),d=n.dot(c,i);if(a+=d,u+=d,h>u||a>l)return!0;if(o){let t=0;if(h<a)if(o.AInB=!1,l<u)t=l-a,o.BInA=!1;else{let[e,r]=[l-a,u-h];t=e<r?e:-r}else if(o.BInA=!1,l>u)t=h-u,o.AInB=!1;else{let[e,r]=[l-a,u-h];t=e<r?e:-r}let e=Math.abs(t);e<o.overlap&&(o.overlap=e,n.copy(o.overlapN,i),t<0&&n.flip$(o.overlapN))}}new p,x=new c(0,0,1,1),new g(x.pos[0],x.pos[1]).set([n.vec(x.width,0),n.vec(x.width,x.height),n.vec(0,x.height),n.vec()]);var x;function k(t,e,r){let s=n.vecAB(t.pos,e.pos),i=t.radius+e.radius,o=i*i,h=n.len2(s),l=!(h>o);if(l&&r){let o=Math.sqrt(h);r.A=t,r.B=e,r.overlap=i-o,n.copy(r.overlapN,n.unit$(s)),n.copy(r.overlapV,n.mul(s,r.overlap)),r.AInB=t.radius<=e.radius&&o<=e.radius-t.radius,r.BInA=e.radius<=t.radius&&o<=t.radius-e.radius}return l}function _(t,r,i){let o,h=n.vecAB(t.pos,r.pos),l=r.radius*r.radius,a=t.calcPoints,u=n.vec();for(let c,d,f,g,p=a.length,m=0;m<p;++m){c=m===p-1?0:m+1,d=0===m?p-1:m-1,f=0,g=null,n.copy(u,t.edges[m]),o=n.vecAB(a[m],h),i&&n.len2(o)>l&&(i.AInB=!1);let w=y(u,o);if(w===e){if(n.copy(u,t.edges[d]),w=y(u,n.vecAB(a[d],h)),w===s){let t=n.len(o);if(t>r.radius)return!1;i&&(i.BInA=!1,g=n.unit(o),f=r.radius-t)}}else if(w===s){if(n.copy(u,t.edges[c]),n.sub$(n.copy(o,h),a[c]),w=y(u,o),w===e){let t=n.len(o);if(t>r.radius)return!1;i&&(i.BInA=!1,g=n.unit(o),f=r.radius-t)}}else{let t=n.unit$(n.normal(u)),e=n.dot(o,t),s=Math.abs(e);if(e>0&&s>r.radius)return!1;i&&(g=t,f=r.radius-e,(e>=0||f<2*r.radius)&&(i.BInA=!1))}g&&i&&Math.abs(f)<Math.abs(i.overlap)&&(i.overlap=f,n.copy(i.overlapN,g))}return i&&(i.A=t,i.B=r,n.mul$(n.copy(i.overlapV,i.overlapN),i.overlap)),!0}function E(t,e,r){let s=_(e,t,r);if(s&&r){let t=r.A,e=r.AInB;n.flip$(r.overlapN),n.flip$(r.overlapV),r.A=r.B,r.B=t,r.AInB=r.BInA,r.BInA=e}return s}function b(t,e,r){let s=t.calcPoints,i=e.calcPoints;for(let o=0;o<s.length;++o)if(w(t.pos,s,e.pos,i,t.normals[o],r))return!1;for(let o=0;o<i.length;++o)if(w(t.pos,s,e.pos,i,e.normals[o],r))return!1;if(r){if(0===r.overlap||a.feq0(r.overlap))return!1;r.A=t,r.B=e,n.copy(r.overlapV,r.overlapN),n.mul$(r.overlapV,r.overlap)}return!0}return{Rect:c,Area:d,Line:f,Circle:class{constructor(t){this.radius=t,this.orient=0,this.pos=n.vec()}setOrient(t){return this.orient=t,this}setPos(t,e){return n.set(this.pos,t,e),this}},Polygon:g,Manifold:p,orderVertices:t=>u(t),polyArea(t,e=!1){let r=e?this.orderVertices(t):t,s=0;for(let t,e,i,o=r.length,n=0;n<o;++n)i=(n+1)%o,t=r[n],e=r[i],s+=t[0]*e[1]-e[0]*t[1];return h(l(s)/2)},calcPolygonCenter(t,e=!1){const r=e?this.orderVertices(t):t,s=6*this.polyArea(r);let i=0,o=0;for(let t,e,s,n=0,h=r.length;n<h;++n)s=(n+1)%h,t=r[n],e=r[s],i+=(t[0]+e[0])*(t[0]*e[1]-e[0]*t[1]),o+=(t[1]+e[1])*(t[0]*e[1]-e[0]*t[1]);return n.vec(h(i/s),h(o/s))},getAABB(t,e=null){if(e||(e=t.pos),a.has(t,"radius"))return new c(e[0]-t.radius,e[1]-t.radius,2*t.radius,2*t.radius);{let r=n.translate(e,t.calcPoints),s=r[0][0],i=r[0][1],o=s,h=i;for(let t,e=1;e<r.length;++e)t=r[e],t[0]<s&&(s=t[0]),t[0]>o&&(o=t[0]),t[1]<i&&(i=t[1]),t[1]>h&&(h=t[1]);return new c(s,i,o-s,h-i)}},shiftPoints:(t,e)=>t.map(t=>n.add(t,e)),rotPoints:(t,e,r)=>t.map(t=>n.rot(t,e,r)),calcRectPoints(t,e){const r=h(t/2),s=h(e/2);return[n.vec(r,-s),n.vec(r,s),n.vec(-r,s),n.vec(-r,-s)]},line:(t,e,r,s)=>new f(t,e,r,s),rectEqRect:(t,e)=>t.width===e.width&&t.height===e.height&&t.pos[0]===e.pos[0]&&t.pos[1]===e.pos[1],rectContainsRect:(t,e)=>!(t.pos[0]>=e.pos[0]||t.pos[1]>=e.pos[1]||t.pos[0]+t.width<=e.pos[0]+e.width||t.pos[1]+t.height<=e.pos[1]+e.height),rectGetMaxX:t=>t.pos[0]+t.width,rectGetMidX:t=>t.pos[0]+h(t.width/2),rectGetMinX:t=>t.pos[0],rectGetMaxY:t=>t.pos[1]+t.height,rectGetMidY:t=>t.pos[1]+h(t.height/2),rectGetMinY:t=>t.pos[1],rectContainsPoint(t,e,r){return e>=this.rectGetMinX(t)&&e<=this.rectGetMaxX(t)&&r>=this.rectGetMinY(t)&&r<=this.rectGetMaxY(t)},rectOverlayRect:(t,e)=>!(t.pos[0]+t.width<e.pos[0]||e.pos[0]+e.width<t.pos[0]||t.pos[1]+t.height<e.pos[1]||e.pos[1]+e.height<t.pos[1]),rectUnion(t,e){const r=Math.min(t.pos[0],e.pos[0]),s=Math.min(t.pos[1],e.pos[1]);return new c(r,s,Math.max(t.pos[0]+t.width,e.pos[0]+e.width)-r,Math.max(t.pos[1]+t.height,e.pos[1]+e.height)-s)},rectIntersection(t,e){if(this.rectOverlayRect(t,e)){const r=Math.max(t.pos[0],e.pos[0]),s=Math.max(t.pos[1],e.pos[1]);return new c(r,s,Math.min(t.pos[0]+t.width,e.pos[0]+e.width)-r,Math.min(t.pos[1]+t.height,e.pos[1]+e.height)-s)}},hitTestPointCircle(t,e,r){let s=t-r.pos[0],i=e-r.pos[1];return s*s+i*i<=r.radius*r.radius},hitCircleCircle(t,e){let r=new p;if(k(t,e,r))return r},hitTestCircleCircle:(t,e)=>k(t,e,new p),hitPolygonCircle(t,e){let r=new p;if(_(t,e,r))return r},hitTestPolygonCircle:(t,e)=>_(t,e,new p),hitCirclePolygon(t,e){let r=new p;if(E(t,e,r))return r},hitTestCirclePolygon:(t,e)=>E(t,e,new p),hitPolygonPolygon(t,e){let r=new p;if(b(t,e,r))return r},hitTestPolygonPolygon:(t,e)=>b(t,e,new p),hitTestPointInPolygon(t,e,r){let s;for(let i,o,n=r.length,h=0,l=n-1;h<n;)i=r[h],o=r[l],i[1]>e!=o[1]>e&&t<(o[0]-i[0])*(e-i[1])/(o[1]-i[1])+i[0]&&(s=!s),l=h,++h;return s},hitTestPointPolygon(t,e,r){return this.hitTestPointInPolygon(t,e,n.translate(r.pos,r.calcPoints))},hitTestLinePolygon(t,e,r){let s=g.translateCalcPoints(r);for(let r=0,i=0;r<s.length;++r){i=r+1,i==s.length&&(i=0);let[o,n]=this.lineIntersect2D(t,e,s[r],s[i]);if(o)return[o,n]}return[!1]},lineIntersect2D(t,e,r,s){let i,o,n=t[0],h=t[1],l=e[0],u=e[1],c=r[0],d=r[1],f=s[0],g=s[1],p=(n-l)*(d-g)-(h-u)*(c-f);return a.feq0(p)?[!1]:(i=(n-c)*(d-g)-(h-d)*(c-f),i/=p,o=(n-c)*(h-u)-(h-d)*(n-l),o/=p,0<=i&&i<=1&&0<=o&&o<=1?[!0,i,[n+i*(l-n),h+i*(u-h)]]:[!1])}}}"object"==typeof module&&module.exports?module.exports=i(require("./core"),require("./math"),require("./vec2")):t["io/czlab/mcfud/geo2d"]=i}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const r=Math.floor,{u:s,is:i}=e;return{spatialGrid:(t=320,e=320)=>function(t,e){const o=new Map;return{searchAndExec(t,e){let r,s=t.getSpatial();for(let i,n,h=s.y1;h<=s.y2;++h)if(n=o.get(h))for(let o,l,a=s.x1;a<=s.x2;++a)if(i=n.get(a))for(o=i.values(),l=o.next();!l.done;){if(t!==l.value&&(r=e(t,l.value))){a=h=1/0;break}r=null,l=o.next()}return r},search(t,e=!1){let r,s,i=[],n=t.getSpatial();for(let h=n.y1;h<=n.y2;++h)if(s=o.get(h))for(let o=n.x1;o<=n.x2;++o)(r=s.get(o))&&r.forEach(r=>{(r!==t||e)&&i.push(r)});return i},engrid(s,i){if(!s)return;let o=s.getBBox(),n=s.getSpatial(),h=r(o.x1/t),l=r(o.y1/e),a=r(o.x2/t),u=r(o.y2/e);return n.x1===h&&n.x2===a&&n.y1===l&&n.y2===u||(this.degrid(s),n.x1=h,n.x2=a,n.y1=l,n.y2=u,i||this._register(s)),s},reset(){o.clear()},_register(t){let e=t.getSpatial();if(i.num(e.x1))for(let r,i,n=e.y1;n<=e.y2;++n){o.has(n)||o.set(n,new Map),i=o.get(n);for(let o=e.x1;o<=e.x2;++o)i.has(o)||i.set(o,new Map),r=i.get(o),s.assoc(r,t.getGuid(),t)}},degrid(t){if(t){let e=t.getSpatial();if(i.num(e.x1))for(let r,i,n=e.y1;n<=e.y2;++n)if(i=o.get(n))for(let o=e.x1;o<=e.x2;++o)(r=i.get(o))&&s.dissoc(r,t.getGuid())}}}}(t,e)}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/spatial"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const r=Math.floor,{u:s}=e;function i(t,e,o,h,l,a,u){let c=null,d=[],f=o<h,g=r((t+e)/2),p=r((o+h)/2);function m(t){let e,r,s,i;if(t.getBBox){let{x1:o,x2:n,y1:h,y2:l}=t.getBBox();e=o,r=h,s=n-o,i=f?l-h:h-l}else void 0!==t.x&&void 0!==t.y&&void 0!==t.width&&void 0!==t.height&&(e=t.x,r=t.y,s=t.width,i=t.height);let o=[],n=e<g,h=e+s>g,l=f?r+i>p:r<p;return(f?r<p:r+i>p)&&(n&&o.push(3),h&&o.push(0)),l&&(n&&o.push(2),h&&o.push(1)),o}function y(){s.assert(null===c),c=[i(g,e,o,p,l,a,u+1),i(g,e,p,h,l,a,u+1),i(t,g,p,h,l,a,u+1),i(t,g,o,p,l,a,u+1)]}const w={x1:t,x2:e,y1:o,y2:h};return{boundingBox:()=>w,subTrees:()=>c,dbg:t=>t(d,c,l,a,u),insert:function(t){for(let e=0;e<arguments.length;++e)t=arguments[e],c?m(t).forEach(e=>c[e].insert(t)):(d.push(t),d.length>l&&u<a&&(y(),d.forEach(t=>m(t).forEach(e=>c[e].insert(t))),d.length=0))},remove(t){c?c.forEach(e=>e.remove(t)):s.disj(d,t)},isLeaf:()=>null===c?-1:d.length,prune(){if(c){let t=0,e=0;for(let r,s=0;s<c.length;++s)r=c[s],r.prune(),n=r.isLeaf(),n>=0&&(++t,e+=n);t===c.length&&e<l&&(s.assert(0===d.length,"quadtree wanted zero items"),c.forEach(t=>t._swap(d)),c=null)}},_swap(t){d.forEach(e=>t.push(e)),d.length=0},reset(){d.length=0,c&&c.forEach(t=>t.reset()),c=null},searchAndExec(t,e,r){let s;if(c){let i=m(t);for(let o=0;o<i.length&&(s=c[i[o]].searchAndExec(t,e,r),!s);++o);}else for(let i,o=0;o<d.length&&(i=d[o],r&&i===t||!(s=e(i,t)));++o);return s},search(t,e){const r=new Map,s=[];return e&&r.set(t,null),c&&m(t).forEach(e=>{c[e].search(t).forEach(t=>{r.has(t)||(r.set(t,null),s.push(t))})}),d.forEach(t=>{r.has(t)||(r.set(t,null),s.push(t))}),r.clear(),s}}}return{quadtree(t,e=12,r=5){const{left:s,right:o,top:n,bottom:h}=t;return i(s,o,n,h,e,r,0)}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/qtree"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const{u:r}=e;class s{constructor(t,e){this.lastBestMove=null,this.state=null,this.other=e,this.cur=t}clone(t){const e=new s;return e.state=t(this.state),e.lastBestMove=this.lastBestMove,e.other=this.other,e.cur=this.cur,e}}function i(t,e,r,s){return t.evalScore(e,r,s)*(1+.001*r)}function o(t,e,s,n,h,l){if(0===s||t.isOver(e))return{depth:s,value:i(t,e,s,n)};let a=e,u=t.getStateCopier(),c=r.shuffle(t.getNextMoves(e));for(let i,d,f=0;f<c.length;++f)if(d=c[f],t.undoMove||(r.assert(u,"Missing state copier!"),e=a.clone(u)),t.makeMove(e,d),i=o(t,e,s-1,n,{value:-l.value,move:l.move},{value:-h.value,move:h.move}),t.undoMove&&t.unmakeMove(e,d),i.value=-i.value,i.move=d,i.value>h.value&&(h={value:i.value,move:d,depth:i.depth}),h.value>=l.value)return l;return JSON.parse(JSON.stringify(h))}function n(t,e,s,o,h,l){if(0===s||t.isOver(e))return[i(t,e,s,o),null];let a=r.shuffle(t.getNextMoves(e)),u=t.getStateCopier(),c=e,d=-1/0,f=a[0];s===o&&(c.lastBestMove=f);for(let i,g,p=0;p<a.length&&(t.undoMove||(r.assert(u,"Missing state copier!"),e=c.clone(u)),g=a[p],t.makeMove(e,g),i=-n(t,e,s-1,o,-l,-h)[0],t.undoMove&&t.unmakeMove(e,g),d<i&&(d=i,f=g),!(h<i&&(h=i,s===o&&(c.lastBestMove=g),h>=l)));++p);return[d,c.lastBestMove]}const h={algo:"negamax",GFrame:s,GameBoard:class{constructor(){}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t){}isStalemate(t){}isOver(t){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}takeGFrame(){}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return r.nichts(s)&&(s=h.evalNegaMax(this)),s}},XXevalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let i,o;return[i,o]=n(t,e,s,s,-1/0,1/0),r.nichts(o)&&console.log(`evalNegaMax: score=${i}, pos= ${o}, lastBestMove=${o}`),o},evalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let{value:i,move:n}=o(t,e,s,s,{value:-1/0},{value:1/0});return r.nichts(n)&&console.log(`evalNegaMax: score= ${i}, pos= ${n}`),n}};return h}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/negamax"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const{u:r}=e;class s{constructor(t,e){this.cur=t,this.state=null,this.other=e}clone(t){const e=new s;return e.state=t(this.state),e.other=this.other,e.cur=this.cur,e}}function i(t,e,r,s){return t.evalScore(e,r,s)}function o(t,e,s,n,h,l,a){if(0===s||t.isOver(e))return[i(t,e,s,n),null];let u=e,c=t.getStateCopier(),d=r.shuffle(t.getNextMoves(e));if(a){let i,f,g=d[0],p=-1/0;for(let m=0;m<d.length&&(t.undoMove||(r.assert(c,"Missing state copier!"),e=u.clone(c)),f=d[m],t.makeMove(e,f),i=o(t,e,s-1,n,h,l,!a)[0],t.undoMove&&t.unmakeMove(e,f),h=Math.max(i,h),i>p&&(p=i,g=f),!(l<=h));++m);return[p,g]}{let i,f,g=d[0],p=1/0;for(let m=0;m<d.length&&(t.undoMove||(r.assert(c,"Missing state copier!"),e=u.clone(c)),f=d[m],t.makeMove(e,f),i=o(t,e,s-1,n,h,l,!a)[0],t.undoMove&&t.unmakeMove(e,f),l=Math.min(i,l),i<p&&(p=i,g=f),!(l<=h));++m);return[p,g]}}const n={algo:"minimax",GFrame:s,GameBoard:class{constructor(){this.aiActor=null}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t,e,r){}isStalemate(t){}isOver(t,e){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}takeGFrame(){}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return r.nichts(s)&&(s=n.evalMiniMax(this)),s}},evalMiniMax(t){const e=t.takeGFrame(),s=t.depth;let i,n;return[i,n]=o(t,e,s,s,-1/0,1/0,!0),r.nichts(n)&&console.log(`evalMiniMax: score=${i}, pos= ${n}`),n}};return n}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/minimax"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const r=(t,e)=>t<e?-1:t>e?1:0,s=Math.floor,{is:i,u:o}=e;function n(t){let e="";for(let r=t.iterator();r.hasNext();)e+=r.next()+" ";return e}function h(t){if(!i.num(t)&&!i.str(t))throw Error("expected either number or string");return!0}class l{constructor(t){this.compare=t||r,this.root=null,this.n=0}size(){return this.n}contains(t){return void 0!==this.get(t)}get(t){if(h(t),this.n>0)return function t(e,r,s){return r&&(s=e<r.key?t(e,r.left):e>r.key?t(e,r.right):r.value),s}(t,this.root)}set(t,e){let r=this;h(t),this.root=function t(e,s,i){if(!i)return r.n+=1,{key:e,value:s,left:null,right:null};let o=r.compare(e,i.key);return o<0?i.left=t(e,s,i.left):o>0?i.right=t(e,s,i.right):i.value=s,i}(t,e,this.root)}_getMaxNode(t){for(;null!==t&&null!==t.right;)t=t.right;return t}_getMaxKey(){let t=this._getMaxNode(this.root);if(t)return t.key}_getMinNode(t){for(;null!==t&&null!==t.left;)t=t.left;return t}_getMinKey(){let t=this._getMinNode(this.root);if(t)return t.key}remove(t){let e=this;h(t),this.root=function t(r,s){if(s)if(r<s.key)s.left=t(r,s.left);else if(r>s.key)s.right=t(r,s.right);else if(s.left&&s.right){let i=e._getMaxNode(s.left),o=i.key,n=i.value;i.value=s.value,i.key=s.key,s.key=o,s.value=n,s.left=t(r,s.left)}else s.left?(s=s.left,e.n-=1):s.right?(s=s.right,e.n-=1):(s=null,e.n-=1);return s}(t,this.root)}keys(){let t=new f;return this.forEach((e,r)=>t.enqueue(r)),t}firstKey(){let t,e;return this.n>0&&(t=this.keys(),e=t.head()),e}lastKey(){let t,e;return this.n>0&&(t=this.keys(),e=t.tail()),e}forEach(t,e){function r(t,e){return e&&e.apply(t,Array.prototype.slice.call(arguments,2))}!function t(e,s,i,o){if(!e)return r(i,o);t(e.left,s,i,(function(){r(i,s,e.value,e.key),t(e.right,s,i,(function(){r(i,o)}))}))}(this.root,t,e)}static test(){let t=new l;t.set(3,"3"),t.set(2,"2"),t.set(7,"7"),t.set(1,"1"),console.log("firstKey= "+t.firstKey()),console.log("lastKey= "+t.lastKey()),console.log(n(t.keys())),console.log("k= "+t.get(3)),console.log("has 2 = "+t.contains(2)),console.log("has size = "+t.size()),t.remove(1),console.log("has size = "+t.size()),console.log(n(t.keys())),console.log("k= "+t.get(2))}}function a(t,e=null){return{item:t,next:e}}class u{constructor(){this.first=null,this.n=0}isEmpty(){return null==this.first}size(){return this.n}add(t){this.first=a(t,this.first),this.n++}iterator(){let t=this.first;return{remove(){throw Error("Unsupported")},hasNext:()=>null!=t,next(){if(!this.hasNext())throw Error("NoSuchElementException");let e=t.item;return t=t.next,e}}}static test(){let t=new u;for("to be or not to - be - - that - - - is".split(" ").forEach(e=>t.add(e)),console.log("size of bag = "+t.size()),t=t.iterator();t.hasNext();)console.log(t.next())}}class c{constructor(){this.first=null,this.n=0}isEmpty(){return null==this.first}size(){return this.n}push(t){this.first=a(t,this.first),this.n++}pop(){if(this.isEmpty())throw Error("Stack underflow");let t=this.first.item;return this.first=this.first.next,--this.n,t}peek(){if(this.isEmpty())throw Error("Stack underflow");return this.first.item}toString(){let t="",e=this.iterator();for(;e.hasNext();)t+=e.next()+" ";return t}iterator(){let t=this.first;return{remove(){throw Error("Unsupported")},hasNext:()=>null!=t,next(){if(!this.hasNext())throw Error("NoSuchElementException");let e=t.item;return t=t.next,e}}}static test(){let t=new c;"to be or not to - be - - that - - - is".split(" ").forEach(e=>{"-"!=e?t.push(e):t.isEmpty()||console.log(t.pop()+" ")}),console.log("("+t.size()+" left on stack)")}}class d{constructor(){this.first=null,this.last=null,this.n=0}isEmpty(){return null==this.first}size(){return this.n}peek(){if(this.isEmpty())throw Error("Queue underflow");return this.first.item}enqueue(t){let e=this.last;this.last=a(t),this.isEmpty()?this.first=this.last:e.next=this.last,++this.n}dequeue(){if(this.isEmpty())throw Error("Queue underflow");let t=this.first.item;return this.first=this.first.next,--this.n,this.isEmpty()&&(this.last=null),t}toString(){let t="",e=this.iterator();for(;e.hasNext();)t+=e.next()+" ";return t}iterator(){let t=this.first;return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>null!=t,next(){if(!this.hasNext())throw Error("NoSuchElementException");let e=t.item;return t=t.next,e}}}static test(){let t=new d;"to be or not to - be - - that - - - is".split(" ").forEach(e=>{"-"!=e?t.enqueue(e):t.isEmpty()||console.log(t.dequeue()+" ")}),console.log("("+t.size()+" left on queue)")}}class f{constructor(){this.first=null,this.last=null,this.n=0}isEmpty(){return null==this.first}size(){return this.n}head(){return this.first&&this.first.item}tail(){return this.last&&this.last.item}peek(){if(this.isEmpty())throw Error("Queue underflow");return this.first.item}enqueue(t){let e=this.last;this.last=a(t),this.isEmpty()?this.first=this.last:e.next=this.last,this.n+=1}dequeue(){if(this.isEmpty())throw Error("Queue underflow");let t=this.first.item;return this.first=this.first.next,this.n-=1,this.isEmpty()&&(this.last=null),t}toString(){let t="";for(let e,r=this.iterator();r.hasNext();)t+=e+" ";return t}iterator(){let t=this.first;return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>null!=t,next(){if(!this.hasNext())throw Error("NoSuchElementException");let e=t.item;return t=t.next,e}}}static test(){let t=new f;"to be or not to - be - - that - - - is".split(/\s+/).forEach(e=>{"-"!=e?t.enqueue(e):t.isEmpty()||console.log(t.dequeue()+" ")}),console.log("("+t.size()+" left on queue)")}}class g{constructor(){this.st=new l}get(t){if(o.nichts(t))throw Error("calls get() with null key");return this.st.get(t)}put(t,e){if(o.nichts(t))throw Error("calls put() with null key");void 0===e?this.st.remove(t):this.st.set(t,e)}remove(t){if(o.nichts(t))throw Error("calls remove() with null key");this.st.remove(t)}contains(t){if(o.nichts(t))throw Error("calls contains() with null key");return this.st.contains(t)}size(){return this.st.size()}isEmpty(){return 0==this.size()}keys(){return this.st.keys()}min(){if(this.isEmpty())throw Error("calls min() with empty symbol table");return this.st.firstKey()}max(){if(this.isEmpty())throw Error("calls max() with empty symbol table");return this.st.lastKey()}ceiling(t){if(o.nichts(t))throw Error("argument to ceiling() is null");let e,r,s=this.st.keys().iterator();for(;s.hasNext();)if(r=s.next(),r==t||r>t){e=r;break}if(void 0===e)throw Error("argument to ceiling() is too large");return e}floor(t){if(o.nichts(t))throw Error("argument to floor() is null");let e,r,s=this.st.keys().iterator();for(;s.hasNext();)r=s.next(),(r==t||r<t)&&(e=r);if(void 0===e)throw Error("argument to floor() is too small");return e}static test(){let t=new g;t.put("a",1),t.put("g",9),t.put("c",3),t.put("j",10),t.put("z",26),t.put("x",24),console.log("isEmpty= "+t.isEmpty()),console.log("size= "+t.size()),console.log("get-c= "+t.get("c")),console.log("contains z= "+t.contains("z")),console.log("contains m= "+t.contains("m")),console.log(n(t.keys())),console.log("ceil w= "+t.ceiling("w")),console.log("floor k= "+t.floor("k")),console.log("min = "+t.min()),console.log("max = "+t.max()),t.remove("x"),console.log(n(t.keys()))}}class p{static M=4;Node(t){return{m:t,children:new Array(p.M)}}Entry(t,e,r=null){return{key:t,val:e,next:r}}constructor(t){this.root=this.Node(0),this.compare=t,this._height=0,this.n=0}isEmpty(){return 0==this.size()}size(){return this.n}height(){return this._height}get(t){if(o.nichts(t))throw Error("argument to get() is null");return this._search(this.root,t,this._height)}_search(t,e,r){let s=t.children;if(0==r){for(let r=0;r<t.m;r++)if(0==this.compare(e,s[r].key))return s[r].val}else for(let i=0;i<t.m;i++)if(i+1==t.m||this.compare(e,s[i+1].key)<0)return this._search(s[i].next,e,r-1)}put(t,e){if(o.nichts(t))throw Error("argument key to put() is null");let r=this._insert(this.root,t,e,this._height);if(this.n++,!r)return;let s=this.Node(2);s.children[0]=this.Entry(this.root.children[0].key,null,this.root),s.children[1]=this.Entry(r.children[0].key,null,r),this.root=s,this._height++}_insert(t,e,r,s){let i,o=this.Entry(e,r);if(0==s)for(i=0;i<t.m&&!(this.compare(e,t.children[i].key)<0);i++);else for(i=0;i<t.m;i++)if(i+1==t.m||this.compare(e,t.children[i+1].key)<0){let n=this._insert(t.children[i++].next,e,r,s-1);if(!n)return null;o.key=n.children[0].key,o.val=null,o.next=n;break}for(let e=t.m;e>i;e--)t.children[e]=t.children[e-1];if(t.children[i]=o,t.m++,t.m>=p.M)return this._split(t)}_split(t){let e=s(p.M/2),r=this.Node(e);t.m=e;for(let s=0;s<e;s++)r.children[s]=t.children[e+s];return r}toString(){return function t(e,r,s){let i="",o=e.children;if(0==r)for(let t=0;t<e.m;t++)i+=`${s}${o[t].key} ${o[t].val}\n`;else for(let n=0;n<e.m;n++)n>0&&(i+=`${s}(${o[n].key})\n`),i+=t(o[n].next,r-1,s+"     ");return i}(this.root,this._height,"")+"\n"}static test(){let t=new p(r);t.put("www.cs.princeton.edu","128.112.136.12"),t.put("www.cs.princeton.edu","128.112.136.11"),t.put("www.princeton.edu","128.112.128.15"),t.put("www.yale.edu","130.132.143.21"),t.put("www.simpsons.com","209.052.165.60"),t.put("www.apple.com","17.112.152.32"),t.put("www.amazon.com","207.171.182.16"),t.put("www.ebay.com","66.135.192.87"),t.put("www.cnn.com","64.236.16.20"),t.put("www.google.com","216.239.41.99"),t.put("www.nytimes.com","199.239.136.200"),t.put("www.microsoft.com","207.126.99.140"),t.put("www.dell.com","143.166.224.230"),t.put("www.slashdot.org","66.35.250.151"),t.put("www.espn.com","199.181.135.201"),t.put("www.weather.com","63.111.66.11"),t.put("www.yahoo.com","216.109.118.65"),console.log("cs.princeton.edu:  "+t.get("www.cs.princeton.edu")),console.log("hardvardsucks.com: "+t.get("www.harvardsucks.com")),console.log("simpsons.com:      "+t.get("www.simpsons.com")),console.log("apple.com:         "+t.get("www.apple.com")),console.log("ebay.com:          "+t.get("www.ebay.com")),console.log("dell.com:          "+t.get("www.dell.com")),console.log(""),console.log("size:    "+t.size()),console.log("height:  "+t.height()),console.log(t.toString()),console.log("")}}class m{constructor(t){this.d=t,this.st=new g}put(t,e){if(t<0||t>=this.d)throw Error("Illegal index");o.feq0(e)?this.st.remove(t):this.st.put(t,e)}get(t){if(t<0||t>=this.d)throw Error("Illegal index");return this.st.contains(t)?this.st.get(t):0}nnz(){return this.st.size()}dimension(){return this.d}dot(t){if(this.d!=t.d)throw Error("Vector lengths disagree");let e=0;if(this.st.size()<=t.st.size())for(let r,s=this.st.keys().iterator();s.hasNext();)r=s.next(),t.st.contains(r)&&(e+=this.get(r)*t.get(r));else for(let r,s=t.st.keys().iterator();s.hasNext();)r=s.next(),this.st.contains(r)&&(e+=this.get(r)*t.get(r));return e}dotWith(t){let e=0;for(let r,s=this.st.keys().iterator();s.hasNext();)r=s.next(),e+=t[r]*this.get(r);return e}magnitude(){return Math.sqrt(this.dot(this))}scale(t){let e=new m(this.d);for(let r,s=this.st.keys().iterator();s.hasNext();)r=s.next(),e.put(r,t*this.get(r));return e}plus(t){if(this.d!=t.d)throw Error("Vector lengths disagree");let e=new m(this.d);for(let t,r=this.st.keys().iterator();r.hasNext();)t=r.next(),e.put(t,this.get(t));for(let r,s=t.st.keys().iterator();s.hasNext();)r=s.next(),e.put(r,t.get(r)+e.get(r));return e}toString(){let t="";for(let e,r=this.st.keys().iterator();r.hasNext();)e=r.next(),t+=`(${e}, ${this.st.get(e)}) `;return t}static test(){let t=new m(10),e=new m(10);t.put(3,.5),t.put(9,.75),t.put(6,.11),t.put(6,0),e.put(3,.6),e.put(4,.9),console.log("a = "+t.toString()),console.log("b = "+e.toString()),console.log("a dot b = "+t.dot(e)),console.log("a + b   = "+t.plus(e).toString())}}return{BTree:p,Bag:u,Stack:c,LinkedQueue:d,Queue:f,ST:g,TreeMap:l,SparseVector:m}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core")):t["io/czlab/mcfud/algo/basic"]=e}(this),function(t){"use strict";function e(e,r){e||(e=t["io/czlab/mcfud/core"]()),r||(r=t["io/czlab/mcfud/algo/basic"]());const s=(t,e)=>t<e?-1:t>e?1:0,i=Math.floor,{is:o,u:n}=e,{Bag:h,Stack:l,Node:a}=r;function u(t,e,r){return r(t,e)<0}function c(t,e,r){const s=t[e];t[e]=t[r],t[r]=s}function d(t){for(let e=0;e<t.length;++e)console.log(t[e])}class f{static sort(t,e){const r=t.length;for(let s=1;s<r;++s)for(let r=s;r>0&&u(t[r],t[r-1],e);--r)c(t,r,r-1);return t}static sortRange(t,e,r,s){for(let i=e+1;i<r;++i)for(let r=i;r>e&&u(t[r],t[r-1],s);--r)c(t,r,r-1);return t}static indexSort(t,e){let r=t.length,s=new Array(r);for(let t=0;t<r;++t)s[t]=t;for(let i=1;i<r;++i)for(let r=i;r>0&&u(t[s[r]],t[s[r-1]],e);--r)c(s,r,r-1);return s}static test(){let t="SORTEXAMPLE".split("");d(f.sort(t,s)),t="bed bug dad yes zoo all bad yet".split(" "),d(f.sortRange(t,0,t.length,s))}}class g{static sort(t,e){let r,s,o,n=t.length;for(let h,l=1;l<n;++l){for(s=0,o=l,h=t[l];s<o;)r=s+i((o-s)/2),u(h,t[r],e)?o=r:s=r+1;for(let e=l;e>s;--e)t[e]=t[e-1];t[s]=h}return t}static test(){let t="SORTEXAMPLE".split("");d(g.sort(t,s)),t="bed bug dad yes zoo all bad yet".split(" "),d(g.sort(t,s))}}class p{static sort(t,e){let r,s=t.length;for(let i=0;i<s;++i){r=i;for(let o=i+1;o<s;++o)u(t[o],t[r],e)&&(r=o);c(t,i,r)}return t}static test(){let t="SORTEXAMPLE".split("");d(p.sort(t,s)),t="bed bug dad yes zoo all bad yet".split(" "),d(p.sort(t,s))}}class m{static sort(t,e){let r=t.length,s=1,o=i(r/3);for(;s<o;)s=3*s+1;for(;s>=1;){for(let i=s;i<r;++i)for(let r=i;r>=s&&u(t[r],t[r-s],e);r-=s)c(t,r,r-s);s=i(s/3)}return t}static test(){let t="SORTEXAMPLE".split("");d(m.sort(t,s)),t="bed bug dad yes zoo all bad yet".split(" "),d(m.sort(t,s))}}function y(t,e,r,s,o){if(s<=r);else{let n=r+i((s-r)/2);y(t,e,r,n),y(t,e,n+1,s),function(t,e,r,s,i,o){for(let s=r;s<=i;++s)e[s]=t[s];let n=r,h=s+1;for(let l=r;l<=i;++l)n>s?t[l]=e[h++]:h>i?t[l]=e[n++]:u(e[h],e[n],o)?t[l]=e[h++]:t[l]=e[n++]}(t,e,r,n,s,o)}return t}function w(t,e,r,s,o,n){if(o<=s);else{let h=s+i((o-s)/2);w(t,e,r,s,h,n),w(t,e,r,h+1,o,n),function(t,e,r,s,i,o,n){for(let t=s;t<=o;++t)r[t]=e[t];let h=s,l=i+1;for(let a=s;a<=o;++a)h>i?e[a]=r[l++]:l>o?e[a]=r[h++]:u(t[r[l]],t[r[h]],n)?e[a]=r[l++]:e[a]=r[h++]}(t,e,r,s,h,o,n)}return t}class x{static sort(t,e){let r=new Array(t.length);return y(t,r,0,t.length-1),t}static indexSort(t,e){let r=t.length,s=new Array(r);for(let t=0;t<r;++t)s[t]=t;return w(t,s,new Array(r),0,r-1,e),s}static test(){let t="SORTEXAMPLE".split("");d(x.sort(t,s)),t="bed bug dad yes zoo all bad yet".split(" "),d(x.sort(t,s))}}function y(t,e,r,s){if(r<=e);else{let i=k(t,e,r,s);y(t,e,i-1,s),y(t,i+1,r,s)}return t}function k(t,e,r,s){let i=e,o=t[e],n=r+1;for(;;){for(;u(t[++i],o,s)&&i!=r;);for(;u(o,t[--n],s)&&n!=e;);if(i>=n)break;c(t,i,n)}return c(t,e,n),n}class _{static sort(t,e){function r(t,e,r){let s=t[e];t[e]=t[r],t[r]=s}let s=t.length;for(let n,h=0;h<s;h++){n=0;for(let l=s-1;l>h;l--)i=t[l],o=t[l-1],e(i,o)<0&&(r(t,l,l-1),n++);if(0==n)break}var i,o;return t}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");_.sort(t,s);for(let e=0;e<t.length;++e)console.log(t[e])}}class E{static sort(t,e){return n.shuffle(t),y(t,0,t.length-1,e),t}static select(t,e,r){if(e<0||e>=t.length)throw Error(`index is not between 0 and ${t.length}: ${e}`);n.shuffle(t);let s=0,i=t.length-1;for(;i>s;){let o=k(t,s,i,r);if(o>e)i=o-1;else{if(!(o<e))return t[o];s=o+1}}return t[s]}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");d(E.sort(t,s)),t="SORTEXAMPLE".split(""),d(E.sort(t,s)),n.shuffle(t),t.forEach((e,r)=>console.log(E.select(t,r,s)))}}function b(t,e,r,s){return u(t[e],t[r],s)}function v(t,e){let r;for(;2*t<=e.n&&(r=2*t,r<e.n&&b(e.pq,r,r+1,e.comparator)&&r++,b(e.pq,t,r,e.comparator));)c(e.pq,t,r),t=r}function N(t,e){const r=new Array(t);for(let t=1;t<=e.n;++t)r[t]=e.pq[t];e.pq=r}class M{constructor(t,e){if(this.comparator=t,this.n=0,o.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=i(this.n/2);t>=1;--t)this.sink(t,this)}else this.pq=new Array(o.num(e)?e:2)}isEmpty(){return 0==this.n}size(){return this.n}min(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}_resize(t){n.assert(t>this.n,"bad resize capacity");let e=new Array(t);for(let t=1;t<=this.n;t++)e[t]=this.pq[t];this.pq=e}insert(t){this.n==this.pq.length-1&&this._resize(2*this.pq.length),this.pq[++this.n]=t,this.swim(this.n)}delMin(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return c(this.pq,1,this.n--),this.sink(1),this.pq[this.n+1]=null,this.n>0&&this.n==(this.pq.length-1)/4&&this._resize(this.pq.length/2),t}swim(t){for(;t>1&&this.greater(i(t/2),t);)c(this.pq,t,i(t/2)),t=i(t/2)}sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this.greater(e,e+1)&&e++,!this.greater(t,e))break;c(this.pq,t,e),t=e}}greater(t,e){return this.comparator(this.pq[t],this.pq[e])>0}isMinHeap(){for(let t=1;t<=this.n;t++)if(n.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;t++)if(!n.nichts(this.pq[t]))return!1;return!!n.nichts(this.pq[0])&&this.isMinHeapOrdered(1)}isMinHeapOrdered(t){if(t>this.n)return!0;let e=2*t,r=2*t+1;return!(e<=this.n&&this.greater(t,e))&&(!(r<=this.n&&this.greater(t,r))&&(this.isMinHeapOrdered(e)&&this.isMinHeapOrdered(r)))}iterator(){let t=new M(this.comparator,this.size());for(let e=1;e<=this.n;e++)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new M(s);"PQE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","XAM".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","PLE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}class q{constructor(t,e){if(this.comparator=t,this.n=0,o.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=i(this.n/2);t>=1;--t)v(t,this)}else this.pq=new Array(o.num(e)?e:2)}isEmpty(){return 0==this.n}size(){return this.n}max(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&N(2*this.pq.length,this),this.n+=1,this.pq[this.n]=t,function(t,e){for(;t>1&&b(e.pq,i(t/2),t,e.comparator);)c(e.pq,t,i(t/2)),t=i(t/2)}(this.n,this)}delMax(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return c(this.pq,1,this.n,this.comparator),this.n-=1,v(1,this),this.pq[this.n+1]=null,this.n>0&&this.n==(this.pq.length-1)/4&&N(i(this.pq.length/2),this),t}iterator(){const t=new q(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t="",e=new q(s);"PQE".split("").forEach(t=>e.insert(t)),t+=e.delMax()+" ","XAM".split("").forEach(t=>e.insert(t)),t+=e.delMax()+" ","PLE".split("").forEach(t=>e.insert(t)),t+=e.delMax()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}function z(t,e,r,s){return s(t[e-1],t[r-1])<0}function A(t,e,r){const s=t[e-1];t[e-1]=t[r-1],t[r-1]=s}function T(t,e,r,s){for(;2*e<=r;){let i=2*e;if(i<r&&z(t,i,i+1,s)&&i++,!z(t,e,i,s))break;A(t,e,i),e=i}}class S{static sort(t,e){let r=t.length;for(let s=i(r/2);s>=1;--s)T(t,s,r,e);let s=r;for(;s>1;)A(t,1,s--),T(t,1,s,e);return t}static test(){let t="SORTEXAMPLE".split("");d(S.sort(t,s)),t="bed bug dad yes zoo all bad yet".split(" "),d(S.sort(t,s))}}class P{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;e++)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this.validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this.validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");this.n++,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this.swim(this.n)}minIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}minKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMin(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this.exch(1,this.n--),this.sink(1),n.assert(t==this.pq[this.n+1],"No good"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this.swim(this.qp[t]),this.sink(this.qp[t])}decreaseKey(t,e){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let r=this.compare(this.mKeys[t],e);if(0==r)throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(r<0)throw Error("Calling decreaseKey() with a key strictly greater than the key in the priority queue");this.mKeys[t]=e,this.swim(this.qp[t])}increaseKey(t,e){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let r=this.compare(this.mKeys[t],e);if(0==r)throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(r>0)throw Error("Calling increaseKey() with a key strictly less than the key in the priority queue");this.mKeys[t]=e,this.sink(this.qp[t])}delete(t){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let e=this.qp[t];this.exch(e,this.n--),this.swim(e),this.sink(e),this.mKeys[t]=null,this.qp[t]=-1}validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}greater(t,e){return this.compare(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]])>0}exch(t,e){let r=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=r,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}swim(t){for(;t>1&&this.greater(t/2,t);)this.exch(t,t/2),t/=2}sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this.greater(e,e+1)&&e++,!this.greater(t,e))break;this.exch(t,e),t=e}}iterator(){let t=new P(this.pq.length-1,this.compare);for(let e=1;e<=this.n;e++)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new P(t.length,s);for(let r=0;r<t.length;r++)e.insert(r,t[r]);for(;!e.isEmpty();){let r=e.delMin();console.log(r+" "+t[r])}console.log("");for(let r=0;r<t.length;r++)e.insert(r,t[r]);for(let r,s=e.iterator();s.hasNext();)r=s.next(),console.log(r+" "+t[r]);for(;!e.isEmpty();)e.delMin()}}class j{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;e++)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this.validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this.validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");this.n++,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this.swim(this.n)}maxIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}maxKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMax(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this.exch(1,this.n--),this.sink(1),n.assert(this.pq[this.n+1]==t,"bad delMax"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this.swim(this.qp[t]),this.sink(this.qp[t])}increaseKey(t,e){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)>0)throw Error("Calling increaseKey() with a key that is strictly less than the key in the priority queue");this.mKeys[t]=e,this.swim(this.qp[t])}decreaseKey(t,e){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)<0)throw Error("Calling decreaseKey() with a key that is strictly greater than the key in the priority queue");this.mKeys[t]=e,this.sink(this.qp[t])}delete(t){if(this.validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let e=this.qp[t];this.exch(e,this.n--),this.swim(e),this.sink(e),this.mKeys[t]=null,this.qp[t]=-1}validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}less(t,e){return this.compare(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]])<0}exch(t,e){let r=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=r,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}swim(t){for(;t>1&&this.less(i(t/2),t);)this.exch(t,i(t/2)),t=i(t/2)}sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this.less(e,e+1)&&e++,!this.less(t,e))break;this.exch(t,e),t=e}}iterator(){let t=new j(this.pq.length-1,this.compare);for(let e=1;e<=this.n;e++)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new j(t.length,s);for(let r=0;r<t.length;r++)e.insert(r,t[r]);for(let r,s=e.iterator();s.hasNext();)r=s.next(),console.log(r+" "+t[r]);console.log("");for(let r=0;r<t.length;r++)n.rand()<.5?e.increaseKey(r,t[r]+t[r]):e.decreaseKey(r,t[r].substring(0,1));for(;!e.isEmpty();){let t=e.maxKey(),r=e.delMax();console.log(r+" "+t)}console.log("");for(let r=0;r<t.length;r++)e.insert(r,t[r]);let r=new Array(t.length);for(let e=0;e<t.length;e++)r[e]=e;n.shuffle(r);for(let t=0;t<r.length;t++){let s=e.keyOf(r[t]);e.delete(r[t]),console.log(r[t]+" "+s)}}}return{Insertion:f,BinaryInsertion:g,Selection:p,Shell:m,Merge:x,Bubble:_,Quick:E,MinPQ:M,MaxPQ:q,Heap:S,IndexMinPQ:P,IndexMaxPQ:j}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core"),require("./basic")):t["io/czlab/mcfud/algo/sort"]=e}(this),function(t){"use strict";function e(e,r){e||(e=t["io/czlab/mcfud/core"]()),r||(r=t["io/czlab/mcfud/algo/basic"]());const s=(t,e)=>t<e?-1:t>e?1:0,{is:i,u:o}=(Math.floor,e),{Bag:h,Stack:l,Queue:a}=r;class u{static count(t,e){let r=new Map,s="";for(let s,i=0;i<t.length;++i)s=t[i],s.length<e||(r.has(s)?r.set(s,r.get(s)+1):(r.set(s,1)));return r.set(s,0),Array.from(r.keys()).forEach(t=>{r.get(t)>r.get(s)&&(s=t)}),[s,r.get(s)]}static test(){let t="it was the best of times it was the worst of times\n        it was the age of wisdom it was the age of foolishness\n        it was the epoch of belief it was the epoch of incredulity\n        it was the season of light it was the season of darkness\n        it was the spring of hope it was the winter of despair".split(" "),[e,r]=u.count(t,1);console.log(e+" "+r)}}class c{constructor(){this.n=0,this.first=null}size(){return this.n}isEmpty(){return 0==this.size()}contains(t){if(null===t)throw Error("argument to contains is null");return null!=this.get(t)}get(t){if(null==t)throw Error("argument to get is null");for(let e=this.first;null!=e;e=e.next)if(t==e.key)return e.val}put(t,e){if(null==t)throw Error("first argument to put is null");if(null!=e){for(let r=this.first;null!=r;r=r.next)if(t==r.key)return void(r.val=e);this.first=function(t,e,r){return{key:t,val:e,next:r}}(t,e,this.first),this.n+=1}else this.delete(t)}delete(t){let e=this;if(null==t)throw Error("argument to delete is null");this.first=function t(r,s){return null==r?null:s==r.key?(e.n-=1,r.next):(r.next=t(r.next,s),r)}(this.first,t)}keys(){let t=[];for(let e=this.first;null!=e;e=e.next)t.push(e.key);return t}static eval(t){let e=new c;return t.forEach((t,r)=>e.put(t,r)),e}static test(){let t=c.eval("SEARCHEXAMPLE".split(""));t.keys().forEach(e=>{console.log(`key=${e}, val=${t.get(e)}`)})}}class d{constructor(t){this.mKeys=new Array(2),this.vals=new Array(2),this.compare=t,this.n=0,this.resize=t=>{let e=new Array(t),r=new Array(t);for(let t=0;t<this.n;++t)e[t]=this.mKeys[t],r[t]=this.vals[t];this.vals=r,this.mKeys=e},this.assertOk=t=>{if(null==t)throw Error("Invalid argument");return!0},this.nnil=t=>null==t,this.assertCheck=()=>(()=>{for(let t=1;t<this.size();++t)if(this.compare(this.mKeys[t],this.mKeys[t-1])<0)return!1;return!0})()&&(()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t=0;t<this.size();++t)if(0!=this.compare(this.mKeys[t],this.select(this.rank(this.mKeys[t]))))return!1;return!0})()}isEmpty(){return 0==this.size()}contains(t){return this.assertOk(t)&&void 0!==this.get(t)}get(t){if(this.assertOk(t)&&!this.isEmpty()){let e=this.rank(t);if(e<this.n&&0==this.compare(this.mKeys[e],t))return this.vals[e]}}rank(t){this.assertOk(t);let e,r,s=0,i=this.n-1;for(;s<=i;)if(e=s+Math.floor((i-s)/2),r=this.compare(t,this.mKeys[e]),r<0)i=e-1;else{if(!(r>0))return e;s=e+1}return s}put(t,e){if(this.assertOk(t)&&this.nnil(e))this.delete(t);else{let r=this.rank(t);if(r<this.n&&0==this.compare(this.mKeys[r],t))this.vals[r]=e;else{this.n==this.mKeys.length&&this.resize(2*this.mKeys.length);for(let t=this.n;t>r;--t)this.mKeys[t]=this.mKeys[t-1],this.vals[t]=this.vals[t-1];this.n+=1,this.mKeys[r]=t,this.vals[r]=e,this.assertCheck()}}}delete(t){if(!this.assertOk(t)||!this.isEmpty()){let e=this.rank(t);if(e==this.n||0!=this.compare(this.mKeys[e],t))return;for(let t=e;t<this.n-1;t++)this.mKeys[t]=this.mKeys[t+1],this.vals[t]=this.vals[t+1];this.n-=1,this.mKeys[n]=null,this.vals[n]=null,this.n>0&&this.n==Math.floor(this.mKeys.length/4)&&this.resize(this.mKeys.length/2),this.assertCheck()}}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.min())}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.max())}min(){if(this.isEmpty())throw Error("called min with empty symbol table");return this.mKeys[0]}max(){if(this.isEmpty())throw Error("called max with empty symbol table");return this.mKeys[this.n-1]}select(t){if(t<0||t>=this.size())throw Error("called select with invalid argument: "+t);return this.mKeys[t]}floor(t){let e=this.assertOk(t)&&this.rank(t);if(e<this.n&&0==this.compare(t,this.mKeys[e]))return this.mKeys[e];if(0==e)throw Error("argument to floor is too small");return this.mKeys[e-1]}ceiling(t){let e=this.assertOk(t)&&this.rank(t);if(e==n)throw Error("argument to ceiling is too large");return this.mKeys[e]}size(t,e){return 0==arguments.length?this.n:(this.assertOk(t)&&this.assertOk(e),this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t))}keys(t,e){0==arguments.length&&(t=this.min(),e=this.max()),this.assertOk(t)&&this.assertOk(e);let r=[];if(this.compare(t,e)>0);else{for(let s=this.rank(t);s<this.rank(e);s++)r.push(this.mKeys[s]);this.contains(e)&&r.push(this.mKeys[this.rank(e)])}return r}static eval(t,e){let r=new d(e);return t.forEach((t,e)=>r.put(t,e)),r}static test(){let t=d.eval("SEARCHEXAMPLE".split(""),(t,e)=>t<e?-1:t>e?1:0);t.keys().forEach(e=>{console.log(`${e} = ${t.get(e)}`)})}}class f{constructor(t){this.nil=t=>null==t,this.compare=t,this.root=null,this.assertOk=t=>{if(null==t)throw Error("Invalid argument");return!0},this.assertCheck=()=>(this.isBST(this.root,null,null)||console.log("Not in symmetric order"),this.isSizeConsistent(this.root)||console.log("Subtree counts not consistent"),this.isRankConsistent()||console.log("Ranks not consistent"),this.isBST(this.root,null,null)&&this.isSizeConsistent(this.root)&&this.isRankConsistent()),this.isBST=(t,e,r)=>!!this.nil(t)||!(!this.nil(e)&&this.compare(t.key,e)<=0)&&(!(!this.nil(r)&&this.compare(t.key,r)>=0)&&(this.isBST(t.left,e,t.key)&&this.isBST(t.right,t.key,r))),this.isSizeConsistent=t=>!!this.nil(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(this.isSizeConsistent(t.left)&&this.isSizeConsistent(t.right)),this.isRankConsistent=()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t=0,e=this.keys();t<e.length;++t)if(0!=this.compare(e[t],this.select(this.rank(e[t]))))return!1;return!0}}Node(t,e,r){return{key:t,val:e,size:r,left:null,right:null}}isEmpty(){return 0==this.size()}contains(t){return this.assertOk(t)&&null!=this.get(t)}get(t){return this._getNode(this.root,t)}_getNode(t,e){if(this.assertOk(e)&&this.nil(t))return;let r=this.compare(e,t.key);return r<0?this._getNode(t.left,e):r>0?this._getNode(t.right,e):t.val}put(t,e){this.assertOk(t)&&this.nil(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this.assertCheck())}_putNode(t,e,r){if(this.nil(t))return this.Node(e,r,1);let s=this.compare(e,t.key);return s<0?t.left=this._putNode(t.left,e,r):s>0?t.right=this._putNode(t.right,e,r):t.val=r,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMinNode(this.root),this.assertCheck()}_deleteMinNode(t){return this.nil(t.left)?t.right:(t.left=this._deleteMinNode(t.left),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t)}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMaxNode(this.root),this.assertCheck()}_deleteMaxNode(t){return this.nil(t.right)?t.left:(t.right=this._deleteMaxNode(t.right),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t)}delete(t){this.assertOk(t),this.root=this._deleteNode(root,t),this.assertCheck()}_deleteNode(t,e){if(this.nil(t))return null;let r=this.compare(e,t.key);if(r<0)t.left=this._deleteNode(t.left,e);else if(r>0)t.right=this._deleteNode(t.right,e);else{if(this.nil(t.right))return t.left;if(this.nil(t.left))return t.right;let e=t;(t=this._minNode(e.right)).right=this._deleteMinNode(e.right),t.left=e.left}return t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return this.nil(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return this.nil(t.right)?t:this._maxNode(t.right)}floor(t){if(this.assertOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(this.nil(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(this.nil(t))return null;let r=this.compare(e,t.key);if(0==r)return t;if(r<0)return this._floorNode(t.left,e);let s=this._floorNode(t.right,e);return this.nil(s)?t:s}floor2(t){let e=this._floor2(root,t,null);if(this.nil(e))throw Error("argument to floor is too small");return e}_floor2(t,e,r){if(this.nil(t))return r;let s=this.compare(e,t.key);return s<0?this._floor2(t.left,e,r):s>0?this._floor2(t.right,e,t.key):t.key}ceiling(t){if(this.assertOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(root,t);if(this.nil(e))throw Error("argument to floor is too large");return e.key}_ceilingNode(t,e){if(this.nil(t))return null;let r=this.compare(e,t.key);if(0==r)return t;if(r<0){let r=this._ceilingNode(t.left,e);return r||t}return this._ceilingNode(t.right,e)}select(t){if(t<0||t>=this.size())throw Error("argument to select is invalid: "+t);return this._selectNode(this.root,t)}_selectNode(t,e){if(this.nil(t))return null;let r=this._sizeNode(t.left);return r>e?this._selectNode(t.left,e):r<e?this._selectNode(t.right,e-r-1):t.key}rank(t){return this.assertOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(this.nil(e))return 0;let r=this.compare(t,e.key);return r<0?this._rankNode(t,e.left):r>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){if(0==arguments.length){if(this.isEmpty())return[];t=this.min(),e=this.max()}return this.assertOk(t)&&this.assertOk(e),this._keysNode(this.root,[],t,e)}_keysNode(t,e,r,s){if(this.nil(t));else{let i=this.compare(r,t.key),o=this.compare(s,t.key);i<0&&this._keysNode(t.left,e,r,s),i<=0&&o>=0&&e.push(t.key),o>0&&this._keysNode(t.right,e,r,s)}return e}_sizeNode(t){return this.nil(t)?0:t.size}size(t,e){return 0==arguments.length?this._sizeNode(this.root):(this.assertOk(t)&&this.assertOk(e),this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t))}height(){return this._heightNode(this.root)}_heightNode(t){return this.nil(t)?-1:1+Math.max(this._heightNode(t.left),this._heightNode(t.right))}levelOrder(){let t,e=[],r=[];for(r.push(this.root);r.length>0;)t=r.pop(),this.nil(t)||(e.push(t.key),r.push(t.left,t.right));return e}static eval(t,e){let r=new f(e);return t.forEach((t,e)=>r.put(t,e)),r}static test(){let t=f.eval("SEARCHEXAMPLE".split(""),(t,e)=>t<e?-1:t>e?1:0);t.levelOrder().forEach(e=>{console.log(`${e} = ${t.get(e)}`)}),console.log(""),t.keys().forEach(e=>{console.log(`${e} = ${t.get(e)}`)})}}class g{static BLACK=!1;static RED=!0;constructor(t){this.nil=t=>null==t,this.compare=t,this.root=null,this.assertOk=t=>{if(null==t)throw Error("Invalid argument");return!0},this.assertCheck=()=>{let t=e=>!!this.nil(e)||e.size==this._sizeNode(e.left)+this._sizeNode(e.right)+1&&(t(e.left)&&t(e.right)),e=t=>!!this.nil(t)||!this._isRed(t.right)&&((t===this.root||!this._isRed(t)||!this._isRed(t.left))&&(e(t.left)&&e(t.right))),r=(t,e)=>this.nil(t)?0==e:(this._isRed(t)||e--,r(t.left,e)&&r(t.right,e));return isBST(this.root,null,null)&&t(this.root)&&(()=>{for(let t=0;t<this.size();++t)if(t!=this._rankNode(this.select(t)))return!1;for(let t=0,e=this.keys();t<e.length;++t)if(0!=this.compare(e[t],this.select(this._rankNode(key))))return!1;return!0})()&&e(this.root)&&(()=>{let t=0,e=this.root;for(;null!=e;)this._isRed(e)||t++,e=e.left;return r(this.root,t)})()}}Node(t,e,r,s){return{key:t,val:e,color:r,size:s,left:null,right:null}}_isRed(t){return!this.nil(t)&&t.color===g.RED}_sizeNode(t){return this.nil(t)?0:t.size}isEmpty(){return null===this.root}get(t){return this.assertOk(t)&&this._getNode(this.root,t)}_getNode(t,e){for(;null!=t;){let r=this.compare(e,t.key);if(r<0)t=t.left;else{if(!(r>0))return t.val;t=t.right}}}contains(t){return void 0!==this.get(t)}put(t,e){this.assertOk(t)&&this.nil(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this.root.color=g.BLACK)}_putNode(t,e,r){if(this.nil(t))return this.Node(e,r,g.RED,1);let s=this.compare(e,t.key);return s<0?t.left=this._putNode(t.left,e,r):s>0?t.right=this._putNode(t.right,e,r):t.val=r,this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}deleteMin(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=g.RED),this.root=this._deleteMinNode(this.root),this.isEmpty()||(this.root.color=g.BLACK)}_deleteMinNode(t){return this.nil(t.left)?null:(this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteMinNode(t.left),this._balance(t))}deleteMax(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=g.RED),this.root=this._deleteMaxNode(this.root),this.isEmpty()||(this.root.color=g.BLACK)}_deleteMaxNode(t){return this._isRed(t.left)&&(t=this._rotateRight(t)),this.nil(t.right)?null:(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),t.right=this._deleteMaxNode(t.right),this._balance(t))}delete(t){this.assertOk(t)&&!this.contains(t)||(this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=g.RED),this.root=this._deleteNode(this.root,t),this.isEmpty()||(this.root.color=g.BLACK))}_deleteNode(t,e){if(this.compare(e,t.key)<0)this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteNode(t.left,e);else{if(this._isRed(t.left)&&(t=this._rotateRight(t)),0==this.compare(e,t.key)&&this.nil(t.right))return null;if(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),0==this.compare(e,t.key)){let e=this._minNode(t.right);t.key=e.key,t.val=e.val,t.right=this._deleteMinNode(t.right)}else t.right=this._deleteNode(t.right,e)}return this._balance(t)}_rotateRight(t){if(this.nil(t)||!this._isRed(t.left))throw Error("bad input to rotateRight");let e=t.left;return t.left=e.right,e.right=t,e.color=e.right.color,e.right.color=g.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_rotateLeft(t){if(this.nil(t)||!this._isRed(t.right))throw Error("bad input to rotateLeft");let e=t.right;return t.right=e.left,e.left=t,e.color=e.left.color,e.left.color=g.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_flipColors(t){t.color=!t.color,t.left.color=!t.left.color,t.right.color=!t.right.color}_moveRedLeft(t){return this._flipColors(t),this._isRed(t.right.left)&&(t.right=this._rotateRight(t.right),t=this._rotateLeft(t),this._flipColors(t)),t}_moveRedRight(t){return this._flipColors(t),this._isRed(t.left.left)&&(t=this._rotateRight(t),this._flipColors(t)),t}_balance(t){return this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}height(){return this._height(this.root)}_height(t){return this.nil(t)?-1:1+Math.max(this._height(t.left),this._height(t.right))}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return this.nil(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return this.nil(t.right)?t:this._maxNode(t.right)}floor(t){if(this.assertOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(this.nil(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(this.nil(t))return null;let r=this.compare(e,t.key);if(0==r)return t;if(r<0)return this._floorNode(t.left,e);let s=this._floorNode(t.right,e);return s||t}ceiling(t){if(this.assertOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(this.nil(e))throw Error("argument to ceiling is too small");return e.key}_ceilingNode(t,e){if(this.nil(t))return null;let r=this.compare(e,t.key);if(0==r)return t;if(r>0)return this._ceilingNode(t.right,e);let s=this._ceilingNode(t.left,e);return s||t}select(t){if(t<0||t>=this.size())throw Error("argument to select is invalid: "+t);return this._selectNode(this.root,t)}_selectNode(t,e){if(this.nil(t))return null;let r=this._sizeNode(t.left);return r>e?this._selectNode(t.left,e):r<e?this._selectNode(t.right,e-r-1):t.key}rank(t){return this.assertOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(this.nil(e))return 0;let r=this.compare(t,e.key);return r<0?this._rankNode(t,e.left):r>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){if(0==arguments.length){if(this.isEmpty())return[];t=this.min(),e=this.max()}return this.assertOk(t)&&this.assertOk(e),this._keysNode(this.root,[],t,e)}_keysNode(t,e,r,s){if(!this.nil(t)){let i=this.compare(r,t.key),o=this.compare(s,t.key);i<0&&this._keysNode(t.left,e,r,s),i<=0&&o>=0&&e.push(t.key),o>0&&this._keysNode(t.right,e,r,s)}return e}size(t,e){return 0==argmuments.length?this._sizeNode(this.root):(this.assertOk(t)&&this.assertOk(e),this.compare(t,e)>0?0:this.contains(e)?this._rankNode(e)-this._rankNode(t)+1:this._rankNode(e)-this._rankNode(t))}static eval(t,e){let r=new g(e);return t.forEach((t,e)=>r.put(t,e)),r}static test(){let t=g.eval("SEARCHEXAMPLE".split(""),(t,e)=>t<e?-1:t>e?1:0);t.keys().forEach(e=>{console.log(`${e} = ${t.get(e)}`)})}}class p{static indexOf(t,e){let r=0,s=t.length-1;for(;r<=s;){let i=r+(s-r)/2;if(e<t[i])s=i-1;else{if(!(e>t[i]))return i;r=i+1}}return-1}static test(){let t="84 48 68 10 18 98 12 23 54 57 33 16 77 11 29".split(" ").map(t=>+t).sort();"23 50 10 99 18 23 98 84 11 10 48 77 13 54 98 77 77 68".split(" ").map(t=>+t).forEach(e=>{p.indexOf(t,e)<0&&console.log(e)})}}function m(t,e){if(t<0||t>=e)throw Error(`vertex ${t} is not between 0 and ${e-1}`)}class y{static copy(t){if(t.V()<0)throw Error("Number of vertices must be non-negative");let e=new y(t.V());e.edges=t.E(),e.adjls=new Array(t.V());for(let t=0;t<V;++t)e.adjls[t]=new h;for(let e=0;e<t.V();++e){let r=new l,s=t.adjls[e].iterator();for(;s.hasNext();)r.push(s.next());for(s=r.iterator();s.hasNext();)this.adjls[e].add(s.next())}return e}constructor(t){if(t<0)throw Error("Number of vertices must be non-negative");this.adjls=new Array(t),this.verts=t,this.edges=0;for(let e=0;e<t;++e)this.adjls[e]=new h}V(){return this.verts}E(){return this.edges}addEdge(t,e){m(t,this.verts),m(e,this.verts),this.edges++,this.adjls[t].add(e),this.adjls[e].add(t)}adj(t){return m(t,this.verts),this.adjls[t]}degree(t){return m(t,this.verts),this.adjls[t].size()}toString(){let t=`${this.verts} vertices, ${this.edges} edges\n`;for(let e,r=0;r<this.verts;++r){for(t+=r+": ",e=this.adjls[r].iterator();e.hasNext();)t+=e.next()+" ";t+="\n"}return t}static test(){let t=new y(13),e=[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);console.log(t.toString())}}function w(t,e,r){let s,i=t.adj(e).iterator();for(r.nCount++,r.bMarked[e]=!0;i.hasNext();)s=i.next(),r.bMarked[s]||w(t,s,r)}class x{constructor(t,e){this.bMarked=new Array(t.V()),this.nCount=0,m(e,this.bMarked.length),w(t,e,this)}marked(t){return m(t,this.bMarked.length),this.bMarked[t]}count(){return this.nCount}static test(){let t=new y(13),e=[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);let r=new x(t,0);for(let e=0;e<t.V();++e)r.marked(e)&&console.log(e+" ");console.log(r.count()!=t.V()?"NOT connected":"connected"),r=new x(t,9);for(let e=0;e<t.V();++e)r.marked(e)&&console.log(e+" ");console.log(r.count()!=t.V()?"NOT connected":"connected")}}class k{constructor(t,e){this.bMarked=new Array(t.V()),m(e,this.bMarked.length);let r=new Array(t.V());for(let e=0;e<t.V();++e)r[e]=t.adj(e).iterator();let s,i,o,n=new l;for(this.bMarked[e]=!0,n.push(e);!n.isEmpty();)i=n.peek(),s=r[i],s.hasNext()?(o=s.next(),this.bMarked[o]||(this.bMarked[o]=!0,n.push(o))):n.pop()}marked(t){return m(t,this.bMarked.length),this.bMarked[t]}static test(){let t=new y(13),e=[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);let r=new k(t,0);for(let e=0;e<t.V();++e)r.marked(e)&&console.log(e+" ");console.log("***"),r=new k(t,9);for(let e=0;e<t.V();++e)r.marked(e)&&console.log(e+" ")}}function w(t,e,r){let s,i=t.adj(e).iterator();for(r.bMarked[e]=!0;i.hasNext();)s=i.next(),r.bMarked[s]||(r.edgeTo[s]=e,w(t,s,r))}class _{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,m(e,this.bMarked.length),w(t,e,this)}hasPathTo(t){return m(t,this.bMarked.length),this.bMarked[t]}pathTo(t){if(m(t,this.bMarked.length),!this.hasPathTo(t))return null;let e=new l;for(let r=t;r!=this.s;r=this.edgeTo[r])e.push(r);return e.push(this.s),e}static test(){let t=new y(6),e=[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);let r=new _(t,0);for(let e,s,i,o=0;o<t.V();++o)if(r.hasPathTo(o)){for(e=`0 to ${o}:  `,s=r.pathTo(o).iterator();s.hasNext();)i=s.next(),e+=0==i?i:"-"+i;console.log(e)}else console.log(`0 to ${o}:  not connected\n`)}}class E{Node(t,e,r,s){return{key:t,val:e,height:r,size:s,left:null,right:null}}constructor(t){this.compare=t,this.root=null}isEmpty(){return null==this.root}size(){return this._sizeNode(root)}_sizeNode(t){return null==t?0:t.size}height(){return this._heightNode(this.root)}_heightNode(t){return null==t?-1:t.height}get(t){if(o.nichts(t))throw Error("argument to get() is null");let e=this._getNode(this.root,t);if(e)return e.val}_getNode(t,e){if(!t)return null;let r=this.compare(e,t.key);return r<0?this._getNode(t.left,e):r>0?this._getNode(t.right,e):t}contains(t){return void 0!==this.get(t)}put(t,e){if(o.nichts(t))throw Error("first argument to put() is null");void 0===e?this.delete(t):this.root=this._putNode(this.root,t,e)}_putNode(t,e,r){if(!t)return this.Node(e,r,0,1);let s=this.compare(e,t.key);if(s<0)t.left=this._putNode(t.left,e,r);else{if(!(s>0))return t.val=r,t;t.right=this._putNode(t.right,e,r)}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balanceNode(t)}_balanceNode(t){return this._balanceFactor(t)<-1?(this._balanceFactor(t.right)>0&&(t.right=this._rotateRight(t.right)),t=this._rotateLeft(t)):this._balanceFactor(t)>1&&(this._balanceFactor(t.left)<0&&(t.left=this._rotateLeft(t.left)),t=this._rotateRight(t)),t}_balanceFactor(t){return this._heightNode(t.left)-this._heightNode(t.right)}_rotateRight(t){let e=t.left;return t.left=e.right,e.right=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}_rotateLeft(t){let e=t.right;return t.right=e.left,e.left=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}delete(t){if(o.nichts(t))throw Error("argument to delete() is null");this.contains(t)&&(this.root=this._deleteNode(this.root,t))}_deleteNode(t,e){let r=this.compare(e,t.key);if(r<0)t.left=this._deleteNode(t.left,e);else if(r>0)t.right=this._deleteNode(t.right,e);else{if(!t.left)return t.right;if(!t.right)return t.left;let e=t;(t=min(e.right)).right=this.deleteMin(e.right),t.left=e.left}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)}deleteMin(){if(this.isEmpty())throw Error("called deleteMin() with empty symbol table");this.root=this._deleteMinNode(this.root)}_deleteMinNode(t){return t.left?(t.left=this._deleteMinNode(t.left),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.right}deleteMax(){if(this.isEmpty())throw Error("called deleteMax() with empty symbol table");this.root=this._deleteMaxNode(this.root)}_deleteMaxNode(t){return t.right?(t.right=this._deleteMaxNode(t.right),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.left}min(){if(this.isEmpty())throw Error("called min() with empty symbol table");return this._minNode(root).key}_minNode(t){return t.left?this._minNode(t.left):t}max(){if(this.isEmpty())throw Error("called max() with empty symbol table");return this._maxNode(root).key}_maxNode(t){return t.right?this._maxNode(t.right):t}floor(t){if(o.nichts(t))throw Error("argument to floor() is null");if(this.isEmpty())throw Error("called floor() with empty symbol table");let e=this._floorNode(this.root,t);if(e)return e.key}_floorNode(t,e){if(o.nichts(t))return null;let r=this.compare(e,t.key);if(0==r)return t;if(r<0)return this._floorNode(t.left,e);let s=this._floorNode(t.right,e);return s||t}ceiling(t){if(o.nichts(t))throw Error("argument to ceiling() is null");if(this.isEmpty())throw Error("called ceiling() with empty symbol table");let e=this._ceilingNode(this.root,t);if(e)return e.key}_ceilingNode(t,e){if(o.nichts(t))return null;let r=this.compare(e,t.key);if(0==r)return t;if(r>0)return this._ceilingNode(t.right,e);let s=this._ceilingNode(t.left,e);return s||t}select(t){if(t<0||t>=this.size())throw Error("k is not in range 0-"+(this.size()-1));let e=this._selectNode(root,t);if(e)return e.key}_selectNode(t,e){if(o.nichts(t))return null;let r=this._sizeNode(t.left);return r>e?this._selectNode(t.left,e):r<e?this._selectNode(t.right,e-r-1):t}rank(t){if(o.nichts(t))throw Error("argument to rank() is null");return this._rankNode(t,this.root)}_rankNode(t,e){if(o.nichts(e))return 0;let r=this.compare(t,e.key);return r<0?this._rankNode(t,e.left):r>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(){return this.keysInOrder()}keysInOrder(){let t=new a;return this._keysInOrderNode(this.root,t),t}_keysInOrderNode(t,e){o.nichts(t)||(this._keysInOrderNode(t.left,e),e.enqueue(t.key),this._keysInOrderNode(t.right,e))}keysLevelOrder(){let t=new a;if(!this.isEmpty()){let e=new a;for(e.enqueue(this.root);!e.isEmpty();){let r=e.dequeue();t.enqueue(r.key),r.left||e.enqueue(r.left),r.right&&e.enqueue(r.right)}}return t}keysBetween(t,e){if(o.nichts(t))throw Error("first argument to keys() is null");if(o.nichts(e))throw Error("second argument to keys() is null");let r=new a;return this._keysNode(this.root,r,t,e),r}_keysNode(t,e,r,s){if(t){let i=this.compare(r,t.key),o=this.compare(s,t.key);i<0&&this._keysNode(t.left,e,r,s),i<=0&&o>=0&&e.enqueue(t.key),o>0&&this._keysNode(t.right,e,r,s)}}sizeBetween(t,e){if(o.nichts(t))throw Error("first argument to size() is null");if(o.nichts(e))throw Error("second argument to size() is null");return this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}check(){let t=this;return function e(r,s,i){return!r||!(!s&&t.compare(r.key,s)<=0)&&(!(!i&&t.compare(r.key,i)>=0)&&(e(r.left,s,r.key)&&e(r.right,r.key,i)))}(this.root,null,null)&&function e(r){if(!r)return!0;let s=t._balanceFactor(r);return!(s>1||s<-1)&&(e(r.left)&&e(r.right))}(this.root)&&function e(r){return!r||r.size==t._sizeNode(r.left)+t._sizeNode(r.right)+1&&(e(r.left)&&e(r.right))}(this.root)&&function(){for(let e=0;e<t.size();e++)if(e!=t.rank(t.select(e)))return!1;for(let e,r=t.keys().iterator();r.hasNext();)if(e=r.next(),0!=this.compare(e,t.select(t.rank(key))))return!1;return!0}()}static test(){let t=new E(s);"SEARCHEXAMPLE".split("").forEach((e,r)=>t.put(e,r));for(let e,r=t.keys().iterator();r.hasNext();)e=r.next(),console.log(e+" "+t.get(e))}}return{AVLTreeST:E,DepthFirstPaths:_,NonrecursiveDFS:k,DepthFirstSearch:x,Graph:y,BinarySearch:p,RedBlackBST:g,BST:f,BinarySearchST:d,SequentialSearchST:c,FrequencyCounter:u}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core"),require("./basic")):t["io/czlab/mcfud/algo/search"]=e}(this),function(t){"use strict";function e(e,r,s){e||(e=t["io/czlab/mcfud/core"]()),r||(r=t["io/czlab/mcfud/algo/basic"]()),s||(s=t["io/czlab/mcfud/algo/sort"]());const i=(t,e)=>t<e?-1:t>e?1:0,{is:o,u:n}=(Math.floor,e),{Bag:h,Stack:l,Queue:a,ST:u}=r,{IndexMinPQ:c}=s;function d(t){let e="";for(let r=t.iterator();r.hasNext();)e+=r.next()+" ";return e}function f(t,e){if(t<0||t>=e)throw Error(`vertex ${t} is not between 0 and ${e-1}`)}class g{static copy(t){if(t.V()<0)throw Error("Number of vertices must be non-negative");let e=new g(t.V());e.edges=t.E(),e.adjls=new Array(t.V());for(let t=0;t<V;++t)e.adjls[t]=new h;for(let e=0;e<t.V();++e){let r=new l,s=t.adjls[e].iterator();for(;s.hasNext();)r.push(s.next());for(s=r.iterator();s.hasNext();)this.adjls[e].add(s.next())}return e}constructor(t){if(t<0)throw Error("Number of vertices must be non-negative");this.adjls=new Array(t),this.verts=t,this.edges=0;for(let e=0;e<t;++e)this.adjls[e]=new h}V(){return this.verts}E(){return this.edges}addEdge(t,e){f(t,this.verts),f(e,this.verts),this.edges++,this.adjls[t].add(e),this.adjls[e].add(t)}adj(t){return f(t,this.verts),this.adjls[t]}degree(t){return f(t,this.verts),this.adjls[t].size()}toString(){let t=`${this.verts} vertices, ${this.edges} edges\n`;for(let e,r=0;r<this.verts;++r){for(t+=r+": ",e=this.adjls[r].iterator();e.hasNext();)t+=e.next()+" ";t+="\n"}return t}static test(){let t=new g(13),e=[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);console.log(t.toString())}}class p{constructor(t,e){this.bMarked=new Array(t.V()),this.nCount=0,f(e,this.bMarked.length),this._dfs(t,e)}_dfs(t,e){let r,s=t.adj(e).iterator();for(this.nCount+=1,this.bMarked[e]=!0;s.hasNext();)r=s.next(),this.bMarked[r]||this._dfs(t,r)}marked(t){return f(t,this.bMarked.length),this.bMarked[t]}count(){return this.nCount}static test(){let t=new g(13),e=[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);let r=new p(t,0);for(let e=0;e<t.V();++e)r.marked(e)&&console.log(e+" ");console.log(r.count()!=t.V()?"NOT connected":"connected"),r=new p(t,9);for(let e=0;e<t.V();++e)r.marked(e)&&console.log(e+" ");console.log(r.count()!=t.V()?"NOT connected":"connected")}}class m{constructor(t,e){this.bMarked=new Array(t.V()),f(e,this.bMarked.length);let r=new Array(t.V());for(let e=0;e<t.V();++e)r[e]=t.adj(e).iterator();let s,i,o,n=new l;for(this.bMarked[e]=!0,n.push(e);!n.isEmpty();)i=n.peek(),s=r[i],s.hasNext()?(o=s.next(),this.bMarked[o]||(this.bMarked[o]=!0,n.push(o))):n.pop()}marked(t){return f(t,this.bMarked.length),this.bMarked[t]}static test(){let t=new g(13),e=[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);let r=new m(t,0);for(let e=0;e<t.V();++e)r.marked(e)&&console.log(e+" ");console.log("***"),r=new m(t,9);for(let e=0;e<t.V();++e)r.marked(e)&&console.log(e+" ")}}class y{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,f(e,this.bMarked.length),this._dfs(t,e)}_dfs(t,e){let r,s=t.adj(e).iterator();for(this.bMarked[e]=!0;s.hasNext();)r=s.next(),this.bMarked[r]||(this.edgeTo[r]=e,this._dfs(t,r))}hasPathTo(t){return f(t,this.bMarked.length),this.bMarked[t]}pathTo(t){if(f(t,this.bMarked.length),!this.hasPathTo(t))return null;let e=new l;for(let r=t;r!=this.s;r=this.edgeTo[r])e.push(r);return e.push(this.s),e}static test(){let t=new g(6),e=[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);let r=new y(t,0);for(let e,s,i,o=0;o<t.V();++o)if(r.hasPathTo(o)){for(e=`0 to ${o}:  `,s=r.pathTo(o).iterator();s.hasNext();)i=s.next(),e+=0==i?i:"-"+i;console.log(e)}else console.log(`0 to ${o}:  not connected\n`)}}function w(t,e,r){let s,i=[];for(let e=0;e<t.V();++e)r.mDistTo[e]=1/0;for(e.forEach(t=>{r.bMarked[t]=!0,r.mDistTo[t]=0,i.push(t)});i.length>0;){s=i.shift();for(let e,o=t.adj(s).iterator();o.hasNext();)e=o.next(),r.bMarked[e]||(r.edgeTo[e]=s,r.mDistTo[e]=r.mDistTo[s]+1,r.bMarked[e]=!0,i.push(e))}}class x{constructor(t,e){this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V()),Array.isArray(e)||(e=[e]),function(t,e){if(!t)throw Error("argument is null");let r=0;if(e.bMarked.length,t.forEach(t=>{if(++r,null==t)throw Error("vertex is null");f(t,e.bMarked.length)}),0==r)throw Error("zero vertices")}(e,this),w(t,e,this),function(t,e,r){if(0!=r.mDistTo[e])throw Error(`distance of source ${e} to itself = ${r.mDistTo[e]}`);for(let e=0;e<t.V();++e)for(let s,i,o=t.adj(e).iterator();o.hasNext();){if(i=o.next(),r.hasPathTo(e)!=r.hasPathTo(i))throw s="edge "+e+"-"+i,s+="hasPathTo("+e+") = "+r.hasPathTo(e),s+="hasPathTo("+i+") = "+r.hasPathTo(i),Error(s);if(r.hasPathTo(e)&&r.mDistTo[i]>r.mDistTo[e]+1)throw s="edge "+e+"--"+i,s+="distTo["+e+"] = "+r.mDistTo[e],s+="distTo["+i+"] = "+r.mDistTo[i],Error(s)}for(let s,i,o=0;o<t.V();++o)if(r.hasPathTo(o)&&o!=e&&(i=r.edgeTo[o],r.mDistTo[o]!=r.mDistTo[i]+1))throw s="shortest path edge "+i+"-"+o,s+="distTo["+i+"] = "+r.mDistTo[i],s+="distTo["+o+"] = "+r.mDistTo[o],Error(s)}(t,e,this)}hasPathTo(t){return f(t,this.bMarked.length),this.bMarked[t]}distTo(t){return f(t,this.bMarked.length),this.mDistTo[t]}pathTo(t){if(f(t,this.bMarked.length),!this.hasPathTo(t))return null;let e,r=new l;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])r.push(e);return r.push(e),r}static test(){let t=new g(6),e=[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);console.log(t.toString());let r=new x(t,0);for(let e,s=0;s<t.V();++s)if(r.hasPathTo(s)){e=`0 to ${s} (${r.distTo(s)}):  `;for(let t,i=r.pathTo(s).iterator();i.hasNext();)t=i.next(),e+=0==t?""+t:"-"+t;console.log(e)}else console.log(`0 to ${s} (-):  not connected\n`)}}class k{constructor(t,e,r){if(t<0)throw Error("vertex index must be a non-negative integer");if(e<0)throw Error("vertex index must be a non-negative integer");this.v=t,this.w=e,this._weight=r}weight(){return this._weight}either(){return this.v}other(t){if(t==this.v)return this.w;if(t==this.w)return this.v;throw Error("Illegal endpoint")}compareTo(t){return this._weight<t._weight?-1:this._weight>t._weight?1:0}toString(){return`${this.v}-${this.w} ${this._weight}`}static test(){console.log(new k(12,34,5.67).toString())}}class _{constructor(t){if(t<0)throw Error("Number of vertices must be non-negative");this.adjls=new Array(t),this._V=t,this._E=0;for(let e=0;e<t;++e)this.adjls[e]=new h}static randGraph(t,e){let r=new _(t);if(e<0)throw Error("Number of edges must be non-negative");for(let s,i,o,h=0;h<e;++h)i=n.randInt2(0,t),o=n.randInt2(0,t),s=Math.round(100*n.rand())/100,r.addEdge(new k(i,o,s));return r}clone(){let t=new _(this.V());t._E=this.E();for(let e,r,s=0;s<this.V();++s){for(r=new l,e=this.adjls[s].iterator();e.hasNext();)r.push(e.next());r.forEach(e=>t.adjls[s].add(e))}return t}V(){return this._V}E(){return this._E}addEdge(t){let e=t.either(),r=t.other(e);f(e,this._V),f(r,this._V),this.adjls[e].add(t),this.adjls[r].add(t),this._E+=1}adj(t){return f(t,this._V),this.adjls[t]}degree(t){return f(t,this._V),this.adjls[t].size()}edges(){let t=new h;for(let e,r,s,i=0;i<V;++i)for(r=0,e=this.adjls[i].iterator();e.hasNext();)s=e.next(),s.other(i)>i?t.add(s):s.other(i)==i&&(r%2==0&&t.add(s),++r);return t}toString(){let t=`${this._V} ${this._E}\n`;for(let e,r=0;r<this._V;++r){for(t+=r+": ",e=this.adjls[r].iterator();e.hasNext();)t+=e.next()+" ";t+="\n"}return t}static test(){let t=new _(8),e="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38 2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34 6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(" ").map(t=>+t);for(let r=0;r<e.length;r+=3)f(e[r],8),f(e[r+1],8),t.addEdge(new k(e[r],e[r+1],e[r+2]));console.log(t.toString())}}class E{constructor(t){this.bMarked=new Array(t.V()),this._id=new Array(t.V()),this._size=new Array(t.V()),this.nCount=0;for(let e=0;e<t.V();++e)this.bMarked[e]||(this._dfs(t,e),++this.nCount)}_dfs(t,e){let r,s,i=t.adj(e).iterator();if(this.bMarked[e]=!0,this._id[e]=this.nCount,this._size[this.nCount]+=1,t instanceof _)for(;i.hasNext();)r=i.next(),s=r.other(e),this.bMarked[s]||this._dfs(t,s);else for(;i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}id(t){return f(t,this.bMarked.length),this._id[t]}size(t){return f(t,this.bMarked.length),this._size[this._id[t]]}count(){return this.nCount}connected(t,e){return f(t,this.bMarked.length),f(e,this.bMarked.length),this.id(t)==this.id(e)}static test(){let t=new g(13),e=[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3];for(let r=0;r<e.length;r+=2)t.addEdge(e[r],e[r+1]);let r=new E(t),s=r.count();console.log(s+" components");let i=new Array(s);for(let t=0;t<s;t++)i[t]=[];for(let e=0;e<t.V();e++)i[r.id(e)].push(e);for(let t,e=0;e<s;e++)t="",i[e].forEach(e=>t+=e.toString()+" "),console.log(t)}}class b{static load(t,e){if(t<0)throw Error("number of vertices in a Digraph must be non-negative");let r=new b(t);for(let t=0;t<e.length;t+=2)r.addEdge(e[t],e[t+1]);return r}constructor(t){if(t<0)throw Error("Number of vertices in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=new Array(t),this.adjls=new Array(t);for(let e=0;e<t;e++)this.adjls[e]=new h}clone(){let t=new b(this.V());t._E=this.E(),t._indegree=new Array(t.V());for(let e=0;e<t.V();e++)t._indegree[e]=this._indegree(e);for(let e,r,s=0;s<t.V();s++){for(r=new l,e=this.adjls[s].iterator();e.hasNext();)r.push(e.next());for(e=r.iterator();e.hasNext();)t.adjls[s].add(e.next())}return t}V(){return this._V}E(){return this._E}addEdge(t,e){f(t,this._V),f(e,this._V),this.adjls[t].add(e),this._indegree[e]+=1,++this._E}adj(t){return f(t,this._V),this.adjls[t]}outdegree(t){return f(t,this._V),this.adjls[t].size()}indegree(t){return f(t,this._V),this._indegree[t]}reverse(){let t=new b(this._V);for(let e,r=0;r<this._V;r++)for(e=this.adjls[r].iterater();e.hasNext();)t.addEdge(e.next(),r);return t}toString(){let t=`${this._V} vertices, ${this._E} edges\n`;for(let e,r=0;r<this._V;r++){for(t+=r+": ",e=this.adjls[r].iterator();e.hasNext();)t+=e.next()+" ";t+="\n"}return t}static test(){let t=b.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t));return console.log(t.toString()),t}}class v{constructor(t,e){this.bMarked=new Array(t.V()),o.vec(e)||(e=[e]),this._validateVertices(e),e.forEach(e=>{this.bMarked[e]||this._dfs(t,e)})}_dfs(t,e){this.mCount+=1,this.bMarked[e]=!0;for(let r,s=t.adj(e).iterator();s.hasNext();)r=s.next(),this.bMarked[r]||this._dfs(t,r)}marked(t){return f(t,this.bMarked.length),this.bMarked[t]}count(){return this.mCount}_validateVertices(t){let e=this.bMarked.length,r=0;if(t.forEach(t=>{r++,f(t,e)}),0==r)throw Error("zero vertices")}static test(){let t=b.test(),e=new v(t,[1,2,6]);for(let r=0;r<t.V();r++)e.marked(r)&&console.log(r+" ")}}class N{constructor(t){this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V()),this.mCycle=null;for(let e=0;e<t.V();e++)this.bMarked[e]||null!=this.mCycle||this._dfs(t,e)}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let r,s=t.adj(e).iterator();s.hasNext();){if(r=s.next(),null!=this.mCycle)return;if(this.bMarked[r]){if(this.onStack[r]){this.mCycle=new l;for(let t=e;t!=r;t=this.edgeTo[t])this.mCycle.push(t);this.mCycle.push(r),this.mCycle.push(e),this.check()}}else this.edgeTo[r]=e,this._dfs(t,r)}this.onStack[e]=!1}hasCycle(){return null!=this.mCycle}cycle(){return this.mCycle}check(){if(this.hasCycle()){let t=-1,e=-1;for(let r,s=this.cycle().iterator();s.hasNext();)r=s.next(),-1==t&&(t=r),e=r;if(t!=e)throw Error(`cycle begins with ${t} and ends with ${e}\n`)}return!0}static test(){let t="2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map(t=>+t),e="";[new N(b.test()),new N(b.load(13,t))].forEach(t=>{if(t.hasCycle()){console.log("Directed cycle: "),e="";for(let r=t.cycle().iterator();r.hasNext();)e+=r.next()+" ";console.log(e)}else console.log("No directed cycle")})}}class M{constructor(t,e,r){if(t<0)throw Error("Vertex names must be non-negative integers");if(e<0)throw Error("Vertex names must be non-negative integers");this.v=t,this.w=e,this._weight=r}from(){return this.v}to(){return this.w}weight(){return this._weight}toString(){return`${this.v}->${this.w} ${Number(this._weight).toFixed(2)}`}static test(){console.log(new M(12,34,5.67).toString())}}class q{constructor(t){if(t<0)throw Error("Number of vertices in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=new Array(t),this.adjls=new Array(t);for(let e=0;e<t;e++)this.adjls[e]=new h}static randGraph(t,e){if(e<0)throw Error("Number of edges in a Digraph must be non-negative");let r=new q(t);for(let s=0;s<e;s++)r.addEdge(new M(n.randInt2(0,t),n.randInt2(0,t),.01*_randInt2(0,100)));return r}static load(t,e){if(t<0)throw Error("number of vertices in a Digraph must be non-negative");let r=new q(t);for(let s=0;s<e.length;s+=3)f(e[s],t),f(e[s+1],t),r.addEdge(new M(e[s],e[s+1],e[s+2]));return r}clone(){let t=new q(this.V());t._E=this.E();for(let e=0;e<this.V();e++)t._indegree[e]=this._indegree(e);for(let e,r=0;r<this.V();r++){e=new l;for(let t=this.adjls[r].iterator();t.hasNext();)e.push(t.next());for(let s=e.iterator();s.hasNext();)t.adjls[r].add(s.next())}return t}V(){return this._V}E(){return this._E}addEdge(t){n.assert(t instanceof M,"Expected DirectedEdge");let e=t.from(),r=t.to();f(e,this._V),f(r,this._V),this.adjls[e].add(t),this._indegree[r]+=1,this._E++}adj(t){return f(t,this._V),this.adjls[t]}outdegree(t){return f(t,this._V),this.adjls[t].size()}indegree(t){return f(t,this._V),this._indegree[t]}edges(){let t=new h;for(let e=0;e<this._V;e++)for(let r=this.adj(e).iterator();r.hasNext();)t.add(r.next());return t}toString(){let t=`${this._V} ${this._E}\n`;for(let e=0;e<this._V;e++){t+=e+": ";for(let r=this.adjls[e].iterator();r.hasNext();)t+=r.next()+"  ";t+="\n"}return t}static test(){let t="4 5 0.35\n        5 4 0.35\n        4 7 0.37\n        5 7 0.28\n        7 5 0.28\n        5 1 0.32\n        0 4 0.38\n        0 2 0.26\n        7 3 0.39\n        1 3 0.29\n        2 7 0.34\n        6 2 0.40\n        3 6 0.52\n        6 0 0.58\n        6 4 0.93".split(/\s+/).map(t=>+t),e=q.load(8,t);console.log(e.toString())}}class z{constructor(t){this._pre=new Array(t.V()),this._post=new Array(t.V()),this.preCounter=0,this.postCounter=0,this.postorder=new a,this.preorder=new a,this.bMarked=new Array(t.V());for(let e=0;e<t.V();e++)this.bMarked[e]||this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0,this._pre[e]=this.preCounter++,this.preorder.enqueue(e);for(let r,s=t.adj(e).iterator();s.hasNext();)r=t instanceof q?s.next().to():s.next(),this.bMarked[r]||this._dfs(t,r);this.postorder.enqueue(e),this._post[e]=this.postCounter++}pre(t){return f(t,this.bMarked.length),this._pre[t]}post(t){return f(t,this.bMarked.length),this._post[t]}postOrder(){return this.postorder}preOrder(){return this.preorder}reversePost(){let t=new l,e=this.postorder.iterator();for(;e.hasNext();)t.push(e.next());return t}check(){let t=0;return this.postOrder().forEach(e=>{if(this.post(e)!=t)throw Error("post(v) and post() inconsistent");t++}),t=0,this.preOrder().forEach(e=>{if(this.pre(e)!=t)throw Error("pre(v) and pre() inconsistent");t++}),!0}static test(){let t=b.load(13,"2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map(t=>+t));console.log(t.toString());let e=new z(t);console.log("   v  pre post"),console.log("--------------");for(let r=0;r<t.V();r++)console.log(`${r} ${e.pre(r)} ${e.post(r)}\n`);console.log("Preorder:  "),console.log(d(e.preOrder())),console.log("Postorder:  "),console.log(d(e.postOrder())),console.log(""),console.log("Reverse postorder: "),console.log(d(e.reversePost()))}}class A{constructor(t){n.assert(t instanceof q,"Expected EdgeWeightedDigraph"),this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();e++)this.bMarked[e]||this._dfs(t,e)}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let r,s,i=t.adj(e).iterator();i.hasNext();){if(s=i.next(),r=s.to(),null!=this.mCycle)return;if(this.bMarked[r]){if(this.onStack[r]){this.mCycle=new l;let t=s;for(;t.from()!=r;)this.mCycle.push(t),t=this.edgeTo[t.from()];return void this.mCycle.push(t)}}else this.edgeTo[r]=s,this._dfs(t,r)}this.onStack[e]=!1}hasCycle(){return null!=this.mCycle}cycle(){return this.mCycle}check(){if(this.hasCycle()){let t=null,e=null;for(let r,s=this.cycle().iterator();s.hasNext();){if(null==t&&(t=r),null!=e&&e.to()!=r.from())throw Error(`cycle edges ${e} and ${r} not incident\n`);e=r}if(e.to()!=t.from())throw Error(`cycle edges ${e} and ${t} not incident\n`)}return!0}static test(){let t=13,e=new q(t),r=new Array(t);for(let e=0;e<t;e++)r[e]=e;n.shuffle(r);for(let r,s,i,o=0;o<8;o++){do{s=n.randInt2(0,t),i=n.randInt2(0,t)}while(s>=i);r=n.rand(),e.addEdge(new M(s,i,r))}for(let r=0;r<6;r++)e.addEdge(new M(n.randInt2(0,t),n.randInt2(0,t),n.rand()));console.log(e.toString());let s=new A(e);s.hasCycle()?console.log("Cycle: "+d(s.cycle())):console.log("No directed cycle")}}class T{constructor(t){this.st=new u,t.forEach(t=>t.forEach((t,e)=>{this.st.contains(t)||this.st.put(t,this.st.size())})),this.keys=new Array(this.st.size());for(let t,e=this.st.keys().iterator();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this._graph=new g(this.st.size()),t.forEach(t=>{let e=this.st.get(t[0]);for(let r,s=1;s<t.length;++s)r=this.st.get(t[s]),this._graph.addEdge(e,r)})}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return f(t,this._graph.V()),this.keys[t]}graph(){return this._graph}static test(){let t="JFK MCO\n                  ORD DEN\n                  ORD HOU\n                  DFW PHX\n                  JFK ATL\n                  ORD DFW\n                  ORD PHX\n                  ATL HOU\n                  DEN PHX\n                  PHX LAX\n                  JFK ORD\n                  DEN LAS\n                  DFW HOU\n                  ORD ATL\n                  LAS LAX\n                  ATL MCO\n                  HOU MCO\n                  LAS PHX".split(/\s+/),e=new T(n.partition(2,t)),r=e.graph();["JFK","LAX"].forEach(t=>{if(e.contains(t)){let s=e.indexOf(t);console.log(t);for(let t=r.adj(s).iterator();t.hasNext();)console.log("   "+e.nameOf(t.next()))}else console.log("input not contain '"+t+"'")})}}class S{constructor(t){this.st=new u,t.forEach(t=>t.forEach(t=>{this.st.contains(t)||this.st.put(t,this.st.size())})),this.keys=new Array(this.st.size());for(let t,e=this.st.keys().iterator();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this.graph=new b(this.st.size()),t.forEach(t=>{let e=this.st.get(t[0]);for(let r,s=1;s<t.length;s++)r=this.st.get(t[s]),this.graph.addEdge(e,r)})}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return f(t,this.graph.V()),this.keys[t]}digraph(){return this.graph}static test(){let t="JFK MCO\n              ORD DEN\n              ORD HOU\n              DFW PHX\n              JFK ATL\n              ORD DFW\n              ORD PHX\n              ATL HOU\n              DEN PHX\n              PHX LAX\n              JFK ORD\n              DEN LAS\n              DFW HOU\n              ORD ATL\n              LAS LAX\n              ATL MCO\n              HOU MCO\n              LAS PHX".split(/\s+/),e=[];for(let r=0;r<t.length;r+=2)e.push([t[r],t[r+1]]);let r=new S(e),s=r.digraph();["JFK","ATL","LAX"].forEach(t=>{let e=s.adj(r.indexOf(t)),i=e?e.iterator():null;if(i)for(;i.hasNext();)console.log("   "+r.nameOf(i.next()))})}}class P{constructor(t){if(this._order=null,this.rank=null,t instanceof b){if(!new N(t).hasCycle()){let e=new z(t);this._order=e.reversePost(),this.rank=new Array(t.V());for(let t=0,e=this._order.iterator();e.hasNext();)this.rank[e.next()]=t++}}else if(t instanceof q){if(!new A(t).hasCycle()){let e=new z(t);this._order=e.reversePost()}}}order(){return this._order}hasOrder(){return null!=this._order}rank(t){return f(t,this.rank.length),this.hasOrder()?this.rank[t]:-1}static test(){let t=new S([["Algorithms","Theoretical CS","Databases","Scientific Computing"],["Introduction to CS","Advanced Programming","Algorithms"],["Advanced Programming","Scientific Computing"],["Scientific Computing","Computational Biology"],["Theoretical CS","Computational Biology","Artificial Intelligence"],["Linear Algebra","Theoretical CS"],["Calculus","Linear Algebra"],["Artificial Intelligence","Neural Networks","Robotics","Machine Learning"],["Machine Learning","Neural Networks"]]);for(let e=new P(t.digraph()).order().iterator();e.hasNext();)console.log(t.nameOf(e.next()))}}class j{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,f(e,this.bMarked.length),this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let r,s=t.adj(e).iterator();s.hasNext();)r=s.next(),this.bMarked[r]||(this.edgeTo[r]=e,this._dfs(t,r))}hasPathTo(t){return f(t,this.bMarked.length),this.bMarked[t]}pathTo(t){if(f(t,this.bMarked.length),!this.hasPathTo(t))return null;let e=new l;for(let r=t;r!=this.s;r=this.edgeTo[r])e.push(r);return e.push(this.s),e}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t),r=b.load(13,e),s=new j(r,3);for(let e=0;e<r.V();e++)if(s.hasPathTo(e)){t=`3 to ${e}:  `;for(let r,i=s.pathTo(e).iterator();i.hasNext();)r=i.next(),t+=3==r?""+r:"-"+r;console.log(t)}else console.log(`3 to ${e}:  not connected\n`)}}class O{constructor(t,e){o.vec(e)||(e=[e]),this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();e++)this.mDistTo[e]=1/0;this._validateVertices(e),this._bfs(t,e)}_bfs(t,e){let r=new a;for(e.forEach(t=>{this.bMarked[t]=!0,this.mDistTo[t]=0,r.enqueue(t)});!r.isEmpty();){let e=r.dequeue();for(let s,i=t.adj(e).iterator();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this.mDistTo[s]=this.mDistTo[e]+1,this.bMarked[s]=!0,r.enqueue(s))}}hasPathTo(t){return f(t,this.bMarked.length),this.bMarked[t]}distTo(t){return f(t,this.bMarked.length),this.mDistTo[t]}pathTo(t){if(f(t,this.bMarked.length),!this.hasPathTo(t))return null;let e,r=new l;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])r.push(e);return r.push(e),r}_validateVertices(t){if(!t)throw Error("argument is null");let e=0,r=this.bMarked.length;if(t.forEach(t=>{++e,f(t,r)}),0==e)throw Error("zero vertices")}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t),r=b.load(13,e),s=new O(r,3);for(let e=0;e<r.V();e++)if(t="",s.hasPathTo(e)){t=`3 to ${e} (${s.distTo(e)}):  `;for(let r,i=s.pathTo(e).iterator();i.hasNext();)r=i.next(),t+=3==r?""+r:"->"+r;console.log(t)}else console.log(`3 to ${e} (-):  not connected\n`)}}class C{constructor(t,e,r){n.assert(t instanceof q,"Expected EdgeWeightedDigraph");for(let e,r=t.edges().iterator();r.hasNext();)if(e=r.next(),e.weight()<0)throw Error(`edge ${e} has negative weight`);this._distTo=new Array(t.V()),this.edgeTo=new Array(t.V()),f(e,t.V());for(let e=0;e<t.V();e++)this._distTo[e]=1/0;for(this._distTo[e]=0,this.pq=new c(t.V(),r),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let r=t.adj(e).iterator();r.hasNext();)this._relax(r.next())}}_relax(t){let e=t.from(),r=t.to();this._distTo[r]>this._distTo[e]+t.weight()&&(this._distTo[r]=this._distTo[e]+t.weight(),this.edgeTo[r]=t,this.pq.contains(r)?this.pq.decreaseKey(r,this._distTo[r]):this.pq.insert(r,this._distTo[r]))}distTo(t){return f(t,this._distTo.length),this._distTo[t]}hasPathTo(t){return f(t,this._distTo.length),this._distTo[t]<1/0}pathTo(t){if(f(t,this._distTo.length),!this.hasPathTo(t))return null;let e=new l;for(let r=this.edgeTo[t];null!=r;r=this.edgeTo[r.from()])e.push(r);return e}check(t,e){for(let e=t.edges().iterator();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||null!=this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let r=0;r<t.V();r++)if(r!=e&&null==this.edgeTo[r]&&this._distTo[r]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();e++)for(let r,s,i=t.adj(e).iterator();i.hasNext();)if(s=i.next(),r=s.to(),this._distTo[e]+s.weight()<this._distTo[r])throw Error(`edge ${s} not relaxed`);for(let e,r,s=0;s<t.V();s++)if(null!=this.edgeTo[s]){if(r=this.edgeTo[s],e=r.from(),s!=r.to())throw Error("bad");if(this._distTo[e]+r.weight()!=this._distTo[s])throw Error(`edge ${r} on shortest path not tight`)}return!0}static test(){let t="4 5 0.35\n                  5 4 0.35\n                  4 7 0.37\n                  5 7 0.28\n                  7 5 0.28\n                  5 1 0.32\n                  0 4 0.38\n                  0 2 0.26\n                  7 3 0.39\n                  1 3 0.29\n                  2 7 0.34\n                  6 2 0.40\n                  3 6 0.52\n                  6 0 0.58\n                  6 4 0.93".split(/\s+/).map(t=>+t),e=q.load(8,t),r=new C(e,0,i);for(let t=0;t<e.V();t++)r.hasPathTo(t)?console.log(`0 to ${t} (${Number(r.distTo(t)).toFixed(2)})  ${d(r.pathTo(t))}`):console.log(`0 to ${t}         no path\n`)}}return{DepthFirstDirectedPaths:j,BreadthFirstDirectedPaths:O,SymbolGraph:T,DijkstraSP:C,Topological:P,SymbolDigraph:S,EdgeWeightedDirectedCycle:A,DepthFirstOrder:z,EdgeWeightedDigraph:q,DirectedEdge:M,DirectedCycle:N,DirectedDFS:v,Digraph:b,CC:E,EdgeWeightedGraph:_,Edge:k,BreadthFirstPaths:x,DepthFirstPaths:y,NonrecursiveDFS:m,DepthFirstSearch:p,Graph:g}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core"),require("./basic"),require("./sort")):t["io/czlab/mcfud/algo/graph"]=e}(this),function(t){"use strict";function e(e,r){if(e||(e=t["io/czlab/mcfud/core"]()),!r)throw"Fatal: No Colors!";const{is:s,u:i}=e;function o(t,e){let r="";for(;t>0;)r+=e,--t;return r}function n(t,e){let r=u;return e&&(s.str(t)?r="any"===t||t===e?c:u:t instanceof e&&(r=c)),r}function h(t,e,r){return new Promise((s,i)=>{let o;try{o=r.call(t),o instanceof Promise?o.then((function(t){s(`${t?c:u}: ${e}`)})):(o=o?709394===o?a:c:u,s(`${o}: ${e}`))}catch(t){o=u,s(`${o}: ${e}`)}})}function l(t,e,r,s){return new Promise((i,o)=>{let h;try{h=r.call(t),h=709394===h?c:n(s,null)}catch(t){h=n(s,t)}i(`${h}: ${e}`)})}const[a,u,c]=["Skippd","Failed","Passed"];return{prn(t){const e=t.passed.length,s=t.total,n=e/s*100;console.log(r.white(o(78,"+"))),console.log(r.white.bold(t.title)),console.log(r.white(t.date)),console.log(r.white(o(78,"+"))),t.passed.length>0&&console.log(r.green(t.passed.join("\n"))),t.skippd.length>0&&console.log(r.grey(t.skippd.join("\n"))),t.failed.length>0&&console.log(r.magenta(t.failed.join("\n"))),console.log(r.white(o(78,"="))),console.log(r.yellow(["Passed: ",e,"/",s," [",0|n,"%]"].join(""))),console.log(r.magenta("Failed: "+(s-e))),console.log(r.white(["cpu-time: ",i.prettyMillis(t.duration)].join(""))),console.log(r.white(o(78,"=")))},deftest(t){let[e,r,s,i]=[null,null,null,null];const o={ensure:(t,e)=>(s.push([1,t,e]),o),eerror:(t,e)=>(s.push([911,t,e]),o),begin:t=>(i={},s=[],e=t,o),end(o){r=o;let n=function(){return new Promise((t,o)=>{e&&e(i);let n,a=[];for(let t,e,r=0;r<s.length;++r){switch(e=s[r],e[0]){case 1:t=h(i,e[1],e[2]);break;case 911:t=l(i,e[1],e[2],"any")}n=n?n.then((function(e){return a.push(e),t})):t}n&&n.then((function(e){a.push(e),s.length=0,r&&r(i),t(a)}))})};return(n.title=t)&&n}};return o},_run:t=>new Promise((e,r)=>{t().then((function(t){e(t)}))}),runtest(t,e){const r=Date.now();return this._run(t).then((function(s){const i=Date.now(),o={title:e||t.title,date:(new Date).toString(),total:s.length,duration:i-r,passed:s.filter(t=>"P"===t[0]),skippd:s.filter(t=>"S"===t[0]),failed:s.filter(t=>"F"===t[0])};return new Promise(t=>{t(o)})}))}}}"object"==typeof module&&module.exports?module.exports=e(require("./core"),require("colors/safe")):t["io/czlab/mcfud/test"]=e}(this);